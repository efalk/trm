#!/usr/bin/env python
# -*- coding: utf8 -*-

from __future__ import print_function

usage = """First sentence is the short summary.

This program blah blah blah
for about a paragraph.

Usage:  trm [options] [account]

        -h, --help              this text
        -V, --version           print version and exit
        --rcfile <file>         trm rcfile, overriding ~/.trmrc

        account         identifies the mail server

Exit codes:

        0 - successful return
        2 - user error
        3 - system error, e.g. unable to connect to server

        TRMRC           trm rcfile path, overriding ~/.trmrc
"""

import curses
import errno
import getopt
import os
import re
import signal
import stat
import string
import sys
import time

import screens
import emailaccount
import mbox
import imap
from keycodes import *
from utils import writeLog, loggingEnabled, configGet, configSet

PY3 = sys.version_info[0] >= 3
if PY3:
    import configparser
    basestring = str
    raw_input = input
else:
    import ConfigParser as configparser
    import locale
    locale.setlocale(locale.LC_ALL, '')

# Programming note: under Python2, curses knows nothing about unicode.
# You must manually encode any unicode string before passing to curses.
# See https://stackoverflow.com/a/40082903/338479

VERSION = "1.0"

SPLASH_SCREEN = """
                *** NEWS NEWS ***

        Welcome to trm 1.0 (19 April 2023).

        Type '?' or F1 at any prompt to get help.

        This message will not be displayed again unless it is updated with new
        information.

        Edward Falk falk@efalk.org
        [Type any key to continue]
"""

rcfile = None
mailrc = None
config = None
accounts = []

HOME = os.environ["HOME"] if "HOME" in os.environ else os.path.expanduser('~')

COMMON_HELP = u"""

Common commands:

 F1 ?          this text
 n ↓           next
 p ↑           previous
 ^E            scroll up 1 line
 PGDN > ^F SP  next page
 PGUP < ^B     previous page
 HOME ^        top
 END  $        end
 CR            select current item
 ^L            refresh screen
 ^C            exit trm
 ESC           return to previous screen

 a-zA-Z0-9     select indicated item
"""
# ^Y       scroll down 1 line           TODO terminal converts ^Y to SIGSTP


IMAP_HELP = u"""
 A      show all mailboxes, including unsubscribed
 S      edit subscriptions"""





#       MAIN


def main():
    """main() handles the initial setup before entering curses mode. It
    reads the config files, parses command line arguments, etc. It then
    runs main_func() which enters curses mode operations. main_func()
    is wrapped in a try/catch block that makes sure curses mode is exited
    no matter what happens."""
    global rcfile, mailrc, config, accounts

    term = None

    if "TRMRC" in os.environ:
        rcfile = os.environ["TRMRC"]
    else:
        rcfile = os.path.join(HOME, ".trmrc")

    if "MAILRC" in os.environ:
        mailrc = os.path.expanduser(os.environ["MAILRC"])
    else:
        mailrc = os.path.join(HOME, ".mailrc")

    # Get arguments with getopt
    long_opts = ['help', 'term=', 'rcfile=', 'version']
    try:
        (optlist, args) = getopt.getopt(sys.argv[1:], 'hVb:cL', long_opts)
        for flag, value in optlist:
            if flag in ('-h', "--help"):
                print(usage)
                return 0
            if flag in ('-V', "--version"):
                print("trm version " + VERSION)
                return 0
            elif flag == '-L':
                loggingEnabled = True
            elif flag == "--rcfile":
                rcfile = value
            elif flag == '-c':
                pass
            elif flag == '--term':
                term = value
    except getopt.GetoptError as e:
        print(e)
        sys.exit(2)

    SecurityCheck(rcfile)
    config = ReadConfig(rcfile, mailrc)

    accounts = getAccounts(config)

    if term:
        sys.stdin = open(term,"r")
        sys.stdout = open(term,"w")

    try:
        main_func(curses.initscr())

    except Exception as e:
        curses.endwin()
        print()
        print("trm died with:", e)
        raise
    except KeyboardInterrupt as e:
        curses.endwin()
        print()
        sys.exit(1)
    else:
        curses.endwin()
        WriteConfig(config, rcfile)
        return 0

def main_func(stdscr):
    """This is the section that enters curses mode and calls the
    splash screen (if needed) and then goes to account selection mode."""
    curses.noecho()
    curses.cbreak()
    stdscr.keypad(True)

    # Main loop. The return from each mode determines what thee
    # next will be.
    if configGet(config, "global","splashscreen") != VERSION:
        SplashScreen(stdscr)

    AccountScreen(stdscr, accounts)


#       SPLASH SCREEN

def SplashScreen(win):
    global config
    if not os.path.isfile(rcfile):
        message = "Creating the file " + rcfile + "\n\n" + SPLASH_SCREEN
    else:
        message = SPLASH_SCREEN
    screen = screens.ShortMessage(win, message)
    screen.displayAndWait()
    config.set("global","splashscreen", VERSION)

def HelpScreen(win, text):
    screens.PagerScreen(win, text, 'Help',
        (("↑ Up one", "↓ Down one"), ("PGUP < Page up", "PGDN > Page down"),
            ("HOME ^ Top", "END  $ Bottom"), ("q Exit help",))) \
            .displayAndWait()


#       ACCOUNT SELECTION

ACCOUNT_SCREEN_HELP = u"""
Select the email account to read. "local" refers to email stored
locally on this machine, if any. Use '+' key to add a new
account.""" + COMMON_HELP + """
More commands:

 +             add account
 -             delete currently-selected account
 E             edit currently-selected account
 q             exit trm
 x             same"""

def AccountScreen(win, accounts):
    """Prompt user to select an account. When the user selects
    one, go to MailboxScreen().  If user selects 'q', this function
    returns."""
    opts = [acct.getName() for acct in accounts]
    optScreen = AccountScreenSetup(win, accounts, opts)
    optScreen.display()
    writeLog("About to enter main loop")
    while True:
        ic = win.getch()
        writeLog("Received character %d" % ic)
        if ic in (ord('q'), ord('x'), ESC):
            return ic
        if ic in (ord('?'), curses.KEY_F1):
            HelpScreen(win, ACCOUNT_SCREEN_HELP)
            optScreen.display()
            continue
        if optScreen.commonKeys(ic):
            optScreen.setTopPrompt("Select account. %d/%d, F1 or ? for help: " % \
                (optScreen.getCurrent()+1, len(opts)))
            optScreen.refresh()
            continue
        idx = optScreen.isOptionKey(ic)
        if idx >= 0:
            writeLog("Chose option %d" % idx)
            optScreen = None
            DoMboxScreen(win, accounts[idx])
            optScreen = AccountScreenSetup(win, accounts, opts)
            optScreen.display()
            continue
        writeLog("Ignoring key code %d" % ic)

def AccountScreenSetup(win, accounts, opts):
    long_cmds = ["+ add email account", "- delete selected email account",
        "E edit selected email account"]
    # Commands:
    #  ?  Help       ↑ p Prev   PGUP < PrevPage  HOME ^ Top     + Add     E Edit
    #  CR Select     ↓ n Next   PGDN > NextPage  END  $ Bottom  - Remove

    optScreen = screens.OptionScreen(win, opts, "Select email account",
        (("?  Help", "CR Select"), ("↑ p Prev", "↓ n Next"),
            ("PGUP < PrevPage", "PGDN > NextPage"), ("HOME ^ Top", "END  $ Bottom"),
            ("+ Add", "- Remove"), ("E Edit",)),
        "E+-")
    optScreen.resize()
    optScreen.setTopPrompt("Select account. %d/%d, F1 or ? for help: " % \
        (optScreen.getCurrent()+1, len(opts)))
    return optScreen



#       MAILBOX SELECTION

def DoMboxScreen(win, account):
    """Display and operate the mailbox selection screen. Most
    of the work is done in an MailboxScreen object."""
    # Connect
    if account.acctType == "local":
        writeLog("Open local account")
        mailboxScreen = MboxScreen(win, account)

    elif account.acctType == "imap":
        writeLog("Open imap account")
        mailboxScreen = ImapMboxScreen(win, account)

    else:
        writeLog("Unknown account type: " + account.acctType)
        return

    if not mailboxScreen.connect():
        writeLog("connect failed")
        return
    ic = mailboxScreen.display()

class MailboxScreen(object):
    """Manages the mailbox selection dialog. Meant to be subclassed
    for the various types of mailboxes. Currently only supports
    Berkeley mbox and imap."""
    HELP_TOP = u"""Select the mailbox to read."""
    HELP_BOTTOM = """
More commands:

 +             add mailbox
 -             delete currently-selected mailbox
 q             return to account selection
 x             same

 /regex/        search for items matching regex"""

    def __init__(self, win, account):
        """Depending on account type, connect to server and then display
        list of mailboxes. If user selects 'q', this function reutrns."""
        self.win = win
        self.account = account

    def connect(self):
        """Connect to account and retrieve list of mailboxes."""
        self.account.connect()
        self.mboxes = self.account.getMboxes()
        return True

    def screenSetup(self):
        """Create appropriate OptionScreen object."""

        self.optScreen = optScreen = screens.OptionScreen(self.win, self.mboxes, "Select mailbox",
            (("?  Help", "CR Select"), ("↑ p Prev", "↓ n Next"),
                ("PGUP < PrevPage", "PGDN > NextPage"), ("HOME ^ Top", "END  $ Bottom"),
                ("+ Add", "- Remove")),
            "+-")
        optScreen.resize()
        optScreen.setTopPrompt("Select mailbox. %d/%d, F1 or ? for help: " % \
            (optScreen.getCurrent()+1, len(self.mboxes)))

    def display(self):
        # Display mailboxes and ask user to choose.
        self.screenSetup()
        optScreen = self.optScreen
        win = self.win
        mboxes = self.mboxes
        optScreen.display()
        writeLog("About to enter mailbox loop")
        while True:
            ic = win.getch()
            writeLog("Received character %d" % ic)
            if self.handleKey(ic):
                # handleKey() may have changed something, so re-read these
                optScreen = self.optScreen
                win = self.win
                mboxes = self.mboxes
                continue
            if ic in (ord('q'), ord('x'), ESC):
                self.account.disconnect()
                return ic
            if ic in (ord('?'), curses.KEY_F1):
                self.showHelp()
                continue
            if optScreen.commonKeys(ic):
                optScreen.setTopPrompt("Select mailbox. %d/%d, F1 or ? for help: " % \
                    (optScreen.getCurrent()+1, len(mboxes)))
                optScreen.refresh()
                continue
            idx = optScreen.isOptionKey(ic)
            if idx >= 0:
                # Launch next window
                MessageScreen(win, self.account, mboxes[idx])
                self.screenSetup()
                optScreen = self.optScreen
                optScreen.display()
                continue
            writeLog("Ignoring key code %d" % ic)

    def handleKey(self, ic):
        """handle keys not handled by display(). Return True if handled here"""
        return False

    def showHelp(self):
        hlp = self.HELP_TOP + COMMON_HELP + self.HELP_BOTTOM
        HelpScreen(self.win, hlp)
        self.optScreen.display()

    def emailScreen(self, win, mbox):
        return


class MboxScreen(MailboxScreen):
    """Support for Berkeley mbox email."""
    pass

class ImapMboxScreen(MailboxScreen):
    """Support for imap."""
    HELP_BOTTOM = u"""
 A             show all mailboxes, including unsubscribed
 S             manage subscribed mailboxes
 +             add mailbox
 -             delete currently-selected mailbox
 q             return to account selection
 x             same

 /regex/        search for items matching regex"""

    def connect(self):
        """Connect to account and retrieve list of mailboxes."""
        if not self.__imapLogin():
            return False
        self.mboxes = self.account.getMboxes()
        return True

    def screenSetup(self):
        """Create appropriate OptionScreen object."""
        long_cmds = ["A toggle view all mailboxes", "S manage subscribed mailboxes",
            "+ add mailbox", "- delete selected mailbox"]

        writeLog("Create new options screen, %d items" % len(self.mboxes))
        self.optScreen = optScreen = screens.OptionScreen(self.win, self.mboxes,
            "Select mailbox",
            "choose: ",
            "help",
            "ASNP+-",
            long_cmds)
        optScreen.resize()
        self.__bottomPrompt()

    def handleKey(self, ic):
        """handle keys not recognized by display(). Return True if handled here"""
        # TODO: S key
        if ic == ord('A'):
            self.account.subbedOnly = not self.account.subbedOnly
            self.mboxes = self.account.getMboxes()
            self.optScreen.setOptions(self.mboxes).displayOpts()
            self.__bottomPrompt()
            self.optScreen.refresh()
            return True
        return False

    def showHelp(self):
        hlp = self.HELP_TOP + COMMON_HELP + self.HELP_BOTTOM
        HelpScreen(self.win, hlp)
        self.optScreen.display()

    def __imapLogin(self):
        win = self.win
        account = self.account
        win.erase()
        win.addstr(1,1, "Opening account \"%s\"" % account.getName())
        win.refresh()
        # Attempt to connect. Keep going until user enters a valid password
        # or hits ^C
        needPw = account.needsPasswd()
        while True:
            if needPw:
                pwWin = screens.passwordWindow(win)
                pwWin.display("Enter password, ^C to cancel:")
                pw = pwWin.read()
                win.move(2,1)
                win.clrtoeol()
                writeLog('Received string "%s"' % pw)
                pwWin = None
                win.refresh()
                if pw == None:
                    writeLog("pw was None, returning")
                    return False
                account.setPasswd(pw)
            try:
                win.addstr(2,1, "Logging in ...")
                win.refresh()
                account.connect()
            except imap.imapAuthFailed as e:
                win.addstr(2,1, "Authentication failed, try again")
                win.refresh()
                needPw = True
                continue
            except Exception as e:
                writeLog("Login failed: %s" % e)
                raise
            else:
                break
        writeLog("login successful")
        return True

    def __bottomPrompt(self):
        self.optScreen.setTopPrompt("Select mailbox. %d/%d, F1 or ? for help: " % \
            (self.optScreen.getCurrent()+1, len(self.mboxes)))



#       MESSAGE SELECTION

MESSAGE_HELP_TOP = u"""Select the message to read."""
MESSAGE_HELP_BOTTOM = u"""
 q             commit changes, return to mailbox selection
 x             return without saving changes

 N             next unread
 ^N            next unread with same subject
 P             previous unread
 ^P            previous unread with same subject
 d             delete current email (move to Trash)
 D             delete entire thread
 m             mark as read
 M             mark entire thread as read
 u             mark as unread
 U             mark entire thread as unread
 O             set selector order
 R             reverse selector order
 t             toggle threaded view (TODO)
 +             expand selected thread (TODO)
 -             unexpand selected thread (TODO)
 ^R            refresh view - re-read mailbox (can take a while)
 /             search, see below

Flags:

 *      flagged important
 N      new message
 U      unread message
 D      marked for deletion
 A      answered
 F      forwarded

Search:

 /regex/[modifiers][:cmd:cmd…]        search for messages matching regex

    modifiers; zero or more of:
        s       search Subject line (default if no modifiers specified)
        f       search From line
        t       search To line
        h       search all headers (potentially slow)
        b       search entire body (potentially very slow)

    search commands: zero or more of:
        :d       delete (move to trash)
        :m       move to INBOX
        :m box   move to specified mailbox
        :a file  append to file
        :| cmd   pipe through shell command

    With no commands, switches to a view of only matching articles.
    Use "/<cr>" to clear the filter and view everything again."""

messageStart = False

def MessageScreen(win, account, mbox):
    """Prompt user to select a message. When the user selects one,
    go to DisplayScreen().  If user selects 'x' or 'q', this function
    returns."""
    global messageStart

    optScreen = MessageScreenSetup(win, account, mbox, [])
    optScreen.setBusy(True)
    optScreen.display()

    messageStart = False
    nmsg = mbox.getOverview(lambda mbox,count,final,pct,msg: \
        MessageShowUpdate(optScreen, mbox, count, final, pct, msg))
    messages = mbox.summaries()
    MessageScreenPrompt(optScreen, mbox)
    optScreen.setContent(messages)
    optScreen.setBusy(False)
    optScreen.refresh()

    direction = 1       # where do we go after a delete

    writeLog("About to enter MessageScreen main loop")
    while True:
        ic = win.getch()
        writeLog("Received character %d" % ic)
        c = chr(ic) if ic < 128 else '\0'
        if c == 'q':
            writeLog("TODO: write out changes")
            return ic
        if ic in (ord('x'), ESC):
            return ic
        if ic in (ord('?'), curses.KEY_F1):
            HelpScreen(win, MESSAGE_HELP_TOP + COMMON_HELP + MESSAGE_HELP_BOTTOM)
            optScreen = MessageScreenSetup(win, account, mbox, messages)
            optScreen.display()
            continue
        if c == 'N':
            idx = mbox.nextUnread(optScreen.getCurrent())
            if idx is not None:
                optScreen.moveTo(idx)
            direction = 1
            continue
        if c == 'P':
            idx = mbox.previousUnread(optScreen.getCurrent())
            if idx is not None:
                optScreen.moveTo(idx)
            direction = -1
            continue
        # TODO: d,D,m,M,O,R,t,u
        if optScreen.commonKeys(ic):
            if c == 'n': direction = 1
            if c == 'p': direction = -1
            MessageScreenPrompt(optScreen, mbox)
            optScreen.refresh()
            continue
        idx = optScreen.isOptionKey(ic)
        if idx >= 0:
            writeLog("Chose option %d" % idx)
            optScreen = None
            newIdx = idx
            while idx is not None:
                # Launch email viewer
                ic = EmailScreen(win, account, mbox, idx)
                c = chr(ic) if ic < 128 else '\0'
                if c == 'n':
                    idx = mbox.nextMessage(idx)
                    direction = 1
                elif c == 'p':
                    idx = mbox.previousMessage(idx)
                    direction = -1
                elif c == 'N':
                    idx = mbox.nextUnread(idx)
                    direction = 1
                elif c == 'P':
                    idx = mbox.previousUnread(idx)
                    direction = -1
                else:
                    idx = None
                if idx is not None: newIdx = idx
                writeLog("New idx = %s" % idx)
            idx = newIdx
            optScreen = MessageScreenSetup(win, account, mbox, messages)
            optScreen.resize().setCurrent(idx)
            MessageScreenPrompt(optScreen, mbox)
            optScreen.display()
            continue
        writeLog("Ignoring key code %d" % ic)
        # TODO: detect changes

def MessageScreenSetup(win, account, mbox, messages):
    optScreen = MessageOptionScreen(win, messages, mbox.name,
        (("?  Help", "CR Select"), ("↑ p Prev", "↓ n Next"),
            ("N Next Unread", "P Prev Unread"),
            ("PGUP < PrevPage", "PGDN > NextPage"), ("HOME ^ Top", "END  $ Bottom"),
            ("d Delete", ""), ("q Return", "x Abort")),
        "NPdDmMuUORt")
    optScreen.resize()
    MessageScreenPrompt(optScreen, mbox)
    return optScreen

def MessageScreenPrompt(optScreen, mbox, comment=None):
    topPrompt = ["%s   %d messages" % (mbox.getName(), mbox.nmessages())]
    if mbox.nNew is not None: topPrompt.append(", %d new" % mbox.nNew)
    if mbox.nUnread is not None: topPrompt.append(", %d unread" % mbox.nUnread)
    topPrompt.append(": %d/%d, " % (optScreen.getCurrent()+1, mbox.nmessages()))
    topPrompt.append(comment if comment else "F1 or ? for help: ")
    optScreen.setTopPrompt("".join(topPrompt))

def MessageShowUpdate(optScreen, mbox, count, final, pct, msg):
    # If this is called with final=False, then it's a good bet that
    # we're going to be here for a while, so time to start showing status
    global messageStart
    if not final:
        if not messageStart:
            optScreen.setContent(mbox.summaries())
        MessageScreenPrompt(optScreen, mbox, "%d%%. ^C to interrupt" % pct)
        optScreen.refresh()

class MessageOptionScreen(screens.ColumnOptionScreen):
    def resizeColumns(self, wid):
        def setCwids(wids):
            self.cwidths = [(0,3)]
            col = 4
            for wid in wids:
                self.cwidths.append((col, wid))
                col += wid + 2
        if wid > 100:
            datewid = 16
            sizewid = 6
            wid -= 16+6
            wid -= 12            # column gaps
            subjwid = int(wid * 0.6)
            fromwid = wid - subjwid
            setCwids((subjwid, fromwid, datewid, sizewid))
        elif wid > 80:
            datewid = 16
            wid -= 16
            wid -= 10            # column gaps
            subjwid = int(wid * 0.6)
            fromwid = wid - subjwid
            setCwids((subjwid, fromwid, datewid))
        else:
            wid -= 8            # column gaps
            subjwid = int(wid * 0.6)
            fromwid = wid - subjwid
            setCwids((subjwid, fromwid))


#       Message Viewer

EMAIL_HELP = u"""
Email message viewer:

 F1 ?          this text
 ↓ j           down one line
 ↑ k           up one line
 PGDN > ^F SP  next page
 PGUP < ^B     previous page
 HOME ^        top
 END  $        end
 ^L            refresh screen
 ^C            exit trm
 q ESC         return to previous screen
 x             return to previous screen without saving changes

 H             toggle full header view

 n             next message
 p             previous message
 N             next unread
 ^N            next unread with same subject
 P             previous unread
 ^P            previous unread with same subject

 d             delete current email (move to Trash)
 D             delete entire thread
 m             mark as read
 M             mark entire thread as read
 u             mark as unread
 U             mark entire thread as unread"""

def EmailScreen(win, account, mbox, idx):
    """Display the selected message."""

    msg = mbox.getMessage(idx)
    # TODO: handle not found
    # If multipart, search for a text/plain part
    longHeaders = False
    if msg.is_multipart():
        charset = None
        text = None
        html = None
        for part in msg.walk():
            if part.is_multipart():
                continue
            if part.get_param("text/html") is not None:
                # We can use html if plain is not found
                charset = part.get_param("charset")
                text = part.get_payload(decode=True)
            if part.get_param("text/plain") is not None:
                # Found it
                charset = part.get_param("charset")
                text = part.get_payload(decode=True)
                break
    else:
        charset = msg.get_param("charset")
        text = msg.get_payload(decode=True)

    if not text: text = html
    if not text: text = u"No plain text found for this message"
    if charset:
        try:
            text = text.decode(charset, errors="replace")
        except LookupError:
            pass

    optScreen = EmailScreenSetup(win, account, mbox, idx, msg, text, longHeaders)
    optScreen.display()

    writeLog("About to enter EmailScreen main loop")
    while True:
        ic = win.getch()
        c = chr(ic) if ic < 128 else '\0'
        writeLog("Received character %d" % ic)
        if c == 'q':
            writeLog("TODO: write out changes")
            return ic
        if ic in (ord('x'), ESC):
            return ic
        if ic in (ord('?'), curses.KEY_F1):
            HelpScreen(win, EMAIL_HELP)
            optScreen = EmailScreenSetup(win, account, mbox, idx, msg, text, longHeaders)
            optScreen.display()
            continue
        if c == 'H':
            longHeaders = not longHeaders
            optScreen.setContent(EmailContent(msg, text, longHeaders)).refresh()
        if c in "npNPdD":
            return ic
        # TODO: m,M,O,R,t,u
        if optScreen.commonKeys(ic):
            optScreen.refresh()
            continue
        writeLog("Ignoring key code %d" % ic)
        # TODO: detect changes

def EmailScreenSetup(win, account, mbox, idx, msg, text, longHeaders):
    optScreen = screens.PagerScreen(win, EmailContent(msg, text, longHeaders),
        "Message %d/%d" % (idx+1, mbox.nmessages()),
        (("? Help","d Delete"), ("↑ Up one", "↓ Down one"),
            ("PGUP < Page up", "PGDN > Page down"),
            ("HOME ^ Top", "END  $ Bottom"),
            ("n Next msg", "p Prev msg"), ("N Next unread", "P Prev unread"),
            ("q Return", "x Abort")))
    optScreen.resize().display()
    return optScreen

def EmailContent(msg, text, longHeaders):
    headers = []
    if not longHeaders:
        if "From" in msg: headers.append(u"From: " + unicode(msg["From"]))
        if "Subject" in msg: headers.append(u"Subject: " + unicode(msg["Subject"]))
        if "To" in msg: headers.append(u"To: " + unicode(msg["To"]))
        if "Date" in msg: headers.append(u"Date: " + unicode(msg["Date"]))
    else:
        for hdr in msg.keys():
            headers.append(unicode(hdr) + ": " + unicode(msg[hdr]))
    return u"\n".join(headers) + u'\n\n' + text


#       UTILITIES

def SecurityCheck(rcfile):
    try:
        sb = os.stat(rcfile)
    except OSError:
        return

    # Should be read-write to owner only.
    mode = stat.S_IMODE(sb.st_mode)
    if mode & 0177:
        if mode & 066:
            print("\n\n\nWarning: file \"%s\" was readable or writeable" % rcfile)
            print("by others (mode %o)" % mode)
            print("\nThis has been changed to mode 0600 (rw-------) for security.")
            print("If you had any passwords stored in this file,")
            print("you should consider changing them.")
        try:
            os.chmod(rcfile, 0600)
        except Exception as e:
            print('Failed to change mode of "%s" to %o, %s"' % (rcfile, 0600, e), file=sys.stderr)
        if mode & 066:
            raw_input("\nHit enter to continue: ")

def ReadConfig(rcfile, mailrc):
    config = configparser.ConfigParser()
    if os.path.isfile(rcfile):
        try:
            config.read(rcfile)
        except:
            pass
    if not config.has_section("global"):
        config.add_section("global")
        config.set("global","splashscreen", "0")

    # Read the old .mailrc file while we're here
    if os.path.isfile(mailrc):
        try:
            with open(mailrc, "r") as ifile:
                if not config.has_section("mailrc"):
                    config.add_section("mailrc")
                # Looking for "folder" variable.
                for line in ifile:
                    line = line.strip()
                    if line.startswith('#'): continue
                    mo = set_re.match(line)
                    if mo:
                        if mo.group(1) == "folder":
                            config.set("mailrc", "folder", mo.group(2).strip('"'))
        except Exception as e:
            print("Failed to read \"%s\", %s, ignored" % (mailrc, e), file=sys.stderr)

    return config

def WriteConfig(config, rcfile):
    try:
        config.remove_section("mailrc")
        config.write(open(rcfile,"w"))
    except Exception as e:
        print("Failed to write \"%s\"," % rcfile, e, file=sys.stderr)

def getAccounts(config):
    accounts = []
    getLocalAccount(accounts)
    for section in config.sections():
        if section.startswith("account "):
            name = section[8:].strip('"')
            config.set(section, "name", name)
            accounts.append(imap.imapAccount(name, section, config))
    return accounts

set_re = re.compile(r""" *set +(\w+)=(.+)""")   # For parsing .mailrc
def getLocalAccount(accounts):
    """Check for the presence of email on the local machine."""
    def getUserMail():
        path = os.path.join("/var/mail", os.environ["USER"])
        if os.path.isfile(path): return path
        path = os.path.join("/var/spool/mail", os.environ["USER"])
        if os.path.isfile(path): return path
        return None
    if "USER" in os.environ:
        userMail = getUserMail()
        writeLog("userMail = %s" % userMail)
        if userMail:
            # Where will user keep their local mail?
            if config.has_option("mailrc", "folder"):
                folder = config.get("mailrc", "folder")
                if not folder.startswith('/'):
                    folder = os.path.join(HOME, folder)
                    config.set("mailrc", "folder", folder)
                    writeLog("folder = %s" % folder)
            elif os.path.isdir(os.path.join(HOME, "mail")):
                configSet(config, "mailrc", "folder", os.path.join(HOME, "mail"))

            account = mbox.MboxAccount("local", userMail, config)
            accounts.append(account)

def percent(a,b):
    return 100*a//(b-1) if b > 1 else 100


if __name__ == '__main__':
    signal.signal(signal.SIGPIPE, signal.SIG_DFL)
    signal.signal(signal.SIGTSTP, signal.SIG_IGN)
    sys.exit(main())
