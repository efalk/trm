#!/usr/bin/env python
# -*- coding: utf8 -*-

from __future__ import print_function

usage = """First sentence is the short summary.

This program blah blah blah
for about a paragraph.

Usage:  trm [options] [account]

        -h, --help              this text
        -V, --version           print version and exit
        --rcfile <file>         trm rcfile, overriding ~/.trmrc

        account         identifies the mail server

Exit codes:

        0 - successful return
        2 - user error
        3 - system error, e.g. unable to connect to server

        TRMRC           trm rcfile path, overriding ~/.trmrc
"""

import curses
import errno
import getopt
import operator
import os
import re
import signal
import stat
import string
import sys
import time

import screens
import emailaccount
import mbox
import imap
from emailaccount import messageSummary
from emailaccount import parseIso
from keycodes import *
from utils import writeLog, loggingEnabled, configGet, configSet, toUtf

PY3 = sys.version_info[0] >= 3
if PY3:
    import configparser
    from html import unescape
    basestring = str
    raw_input = input
else:
    import ConfigParser as configparser
    import locale
    import HTMLParser
    locale.setlocale(locale.LC_ALL, '')
    parser = HTMLParser.HTMLParser()
    unescape = parser.unescape

# Programming note: under Python2, curses knows nothing about unicode.
# You must manually encode any unicode string before passing to curses.
# See https://stackoverflow.com/a/40082903/338479

VERSION = "1.0"

SPLASH_SCREEN = """
                *** NEWS NEWS ***

        Welcome to trm 1.0 (19 April 2023).

        Type '?' or F1 at any prompt to get help.

        This message will not be displayed again unless it is updated with new
        information.

        Edward Falk falk@efalk.org

        [Type '?' for long help, or any other key to continue]
"""

MAIN_HELP = u"""
This is a relatively simple text-based mail reader. For far more
sophisticated mail readers, see PINE or MUTT. This one is written
to  provide specific search and threading functions.

Navigating through help:

  ↑     up one line
  ↓     down one line
  PGUP  up one page
  PGDN  down one page
  HOME  back to top
  END   go to end
  q     return to previous screen

There are four main screens in trm:

• Account selection
• Mailbox selection
• Message selection
• Message reading

More on these modes below.


Navigation and other common operations:

Trm uses single-key commands in most cases. Navigation can go very quickly.
The following commands are available in all modes. In many cases, there is
more than one key for the same operation:

  F1    ?          F1 or '?' give helps from any page.
  q                "quit". Write out changes and return to previous page
  x                "exit". Return to previous page immediately without writing anything
  ↑     p          "Previous": up-arrow or 'p' moves up one line
  ↓     n          "Next": down-arrow or 'n' moves down one line
  PGUP  <  ^B      Back one page
  PGDN  >  ^F  SP  Forward one page
  HOME  ^          Go to top
  END   $          Go to end
  CR               select current item
  ^L               refresh screen
  ^C               exit trm
  ESC              return to previous screen (same as 'x')

  /                Begin a search.


Short help:

At the bottom of the screen you will see a summary of the most
commonly-used commands for the current mode. It looks something
like this:

    ?  Help      ↑ p Prev      PGUP < PrevPage    HOME ^ Top       + Add
    CR Select    ↓ n Next      PGDN > NextPage    END  $ Bottom    - Remove

There are usually more commands than this available, so use F1 or '?'
to see a more complete list.


More on the different modes:

• Account selection. In this screen, you select the email account
  you wish to read. By default, when you first start using trm,
  "local" is the only option. This refers to the email stored on
  your local system in /var/spool/mail or /var/mail (depending on OS).
  Even "local" won't be present if there is no mail on your
  system.

  The "+" key brings you to a dialog that allows you to add other
  email accounts to trm. At present, only IMAP is supported.

  Selecting an account brings you to:

• Mailbox selection. All of the available mailboxes for this account
  are displayed, with letters next to them. You can select any mailbox
  to read by typing the letter next to it, or by using the usual
  navigation keys to highlight a mailbox and then hitting CR.

• Message selection. Messages are displayed in the usual way. Use
  the navigation keys or type a letter to choose a message to be read.
  The 'S' command changes the sort criteria for the messages (default
  is unsorted - i.e. the order the messages happen to be stored).

  The 'n' and 'p' commands change the selection in the usual way,
  while 'N' and 'P' select the next or previous unread message.
  You can also use 'd' to delete a message, 'm' to mark it as read,
  'u' to mark it as unread, '!' to mark it as important, and so
  forth. Use '?' to get a full list of commands.

• Message reading. This mode simply displays a message. Use the
  navigation keys to scroll back and forth in the usual way.

  Trm doesn't handle attachments (yet). If the message contains a
  "text/plain" section, that is the part which is displayed. Else,
  a "text/html" section, if any.

  The 'n', 'p', 'N', 'P', 'd', 'm', 'u', and '!' commands also
  work in message reading mode. Use '?' for the full list of
  options.
"""


rcfile = None
mailrc = None
config = None
accounts = []

HOME = os.environ["HOME"] if "HOME" in os.environ else os.path.expanduser('~')

COMMON_HELP = u"""

Common commands:

 F1 ?          this text
 n ↓           next
 p ↑           previous
 ^E            scroll up 1 line
 PGDN > ^F SP  next page
 PGUP < ^B     previous page
 HOME ^        top
 END  $        end
 CR            select current item
 ^L            refresh screen
 ^C            exit trm
 ESC           return to previous screen

 a-zA-Z0-9     select indicated item
"""
# ^Y       scroll down 1 line           TODO terminal converts ^Y to SIGSTP


IMAP_HELP = u"""
 A      show all mailboxes, including unsubscribed
 S      edit subscriptions"""





#       MAIN


def main():
    """main() handles the initial setup before entering curses mode. It
    reads the config files, parses command line arguments, etc. It then
    runs main_func() which enters curses mode operations. main_func()
    is wrapped in a try/catch block that makes sure curses mode is exited
    no matter what happens."""
    global rcfile, mailrc, config, accounts

    term = None

    if "TRMRC" in os.environ:
        rcfile = os.environ["TRMRC"]
    else:
        rcfile = os.path.join(HOME, ".trmrc")

    if "MAILRC" in os.environ:
        mailrc = os.path.expanduser(os.environ["MAILRC"])
    else:
        mailrc = os.path.join(HOME, ".mailrc")

    # Get arguments with getopt
    long_opts = ['help', 'term=', 'rcfile=', 'version']
    try:
        (optlist, args) = getopt.getopt(sys.argv[1:], 'hVb:cL', long_opts)
        for flag, value in optlist:
            if flag in ('-h', "--help"):
                print(usage)
                return 0
            if flag in ('-V', "--version"):
                print("trm version " + VERSION)
                return 0
            elif flag == '-L':
                loggingEnabled = True
            elif flag == "--rcfile":
                rcfile = value
            elif flag == '-c':
                pass
            elif flag == '--term':
                term = value
    except getopt.GetoptError as e:
        print(e)
        sys.exit(2)

    SecurityCheck(rcfile)
    config = ReadConfig(rcfile, mailrc)

    accounts = getAccounts(config)

    if term:
        sys.stdin = open(term,"r")
        sys.stdout = open(term,"w")

    try:
        main_func(curses.initscr())

    except Exception as e:
        curses.endwin()
        print()
        print("trm died with:", e)
        raise
    except KeyboardInterrupt as e:
        curses.endwin()
        print()
        sys.exit(1)
    else:
        curses.endwin()
        WriteConfig(config, rcfile)
        return 0

def main_func(stdscr):
    """This is the section that enters curses mode and calls the
    splash screen (if needed) and then goes to account selection mode."""
    curses.noecho()
    curses.cbreak()
    stdscr.keypad(True)

    # Main loop. The return from each mode determines what thee
    # next will be.
    if configGet(config, "global","splashscreen") != VERSION:
        SplashScreen(stdscr)

    AccountScreen(stdscr, accounts)


#       SPLASH SCREEN

def SplashScreen(win):
    global config
    if not os.path.isfile(rcfile):
        message = "Creating the file " + rcfile + "\n\n" + SPLASH_SCREEN
    else:
        message = SPLASH_SCREEN
    screen = screens.ShortMessage(win, message)
    c = screen.displayAndWait()
    config.set("global","splashscreen", VERSION)
    if c in (ord('?'), curses.KEY_F1):
        HelpScreen(win, MAIN_HELP)

def HelpScreen(win, text):
    c = screens.PagerScreen(win, text, 'Help',
        (("↑ Up one", "↓ Down one"), ("PGUP < Page up", "PGDN > Page down"),
            ("HOME ^ Top", "END  $ Bottom"), ("q Exit help", "? long help"))) \
            .displayAndWait()
    if c in (ord('?'), curses.KEY_F1):
        HelpScreen(win, MAIN_HELP)


#       ACCOUNT SELECTION

ACCOUNT_SCREEN_HELP = u"""
Select the email account to read. "local" refers to email stored
locally on this machine, if any. Use '+' key to add a new
account.""" + COMMON_HELP + """
More commands:

 +             add account
 -             delete currently-selected account
 E             edit currently-selected account
 q             exit trm
 x             same"""

def AccountScreen(win, accounts):
    """Prompt user to select an account. When the user selects
    one, go to MailboxScreen().  If user selects 'q', this function
    returns."""
    opts = [acct.name for acct in accounts]
    optScreen = AccountScreenSetup(win, accounts, opts)
    optScreen.display()
    writeLog("About to enter main loop")
    while True:
        ic = win.getch()
        writeLog("Received character %d" % ic)
        if ic in (ord('q'), ord('x'), ESC):
            return ic
        if ic in (ord('?'), curses.KEY_F1):
            HelpScreen(win, ACCOUNT_SCREEN_HELP)
            optScreen.display()
            continue
        if optScreen.commonKeys(ic):
            optScreen.setTopPrompt("Select account. %d/%d, F1 or ? for help: " % \
                (optScreen.getCurrent()+1, len(opts)))
            optScreen.refresh()
            continue
        idx = optScreen.isOptionKey(ic)
        if idx >= 0:
            writeLog("Chose option %d" % idx)
            optScreen = None
            DoMboxScreen(win, accounts[idx])
            optScreen = AccountScreenSetup(win, accounts, opts)
            optScreen.display()
            continue
        writeLog("Ignoring key code %d" % ic)

def AccountScreenSetup(win, accounts, opts):
    long_cmds = ["+ add email account", "- delete selected email account",
        "E edit selected email account"]
    # Commands:
    #  ?  Help       ↑ p Prev   PGUP < PrevPage  HOME ^ Top     + Add     E Edit
    #  CR Select     ↓ n Next   PGDN > NextPage  END  $ Bottom  - Remove

    optScreen = screens.OptionScreen(win, opts, "Select email account",
        (("?  Help", "CR Select"), ("↑ p Prev", "↓ n Next"),
            ("PGUP < PrevPage", "PGDN > NextPage"), ("HOME ^ Top", "END  $ Bottom"),
            ("+ Add", "- Remove"), ("E Edit",)),
        "E+-")
    optScreen.resize()
    optScreen.setTopPrompt("Select account. %d/%d, F1 or ? for help: " % \
        (optScreen.getCurrent()+1, len(opts)))
    return optScreen



#       MAILBOX SELECTION

# PROGRAMMING NOTES:
#
# The behavior of the message selection screen varies depending on
# the mailbox type, so we use an object-oriented approach here.
# The actual working code is in class MailboxScreen or a subclass.
# The entry point to this mode, DoMboxScreen() chooses the
# correct subclass depending on mailbox type.

def DoMboxScreen(win, account):
    """Display and operate the mailbox selection screen. Most
    of the work is done in an MailboxScreen object."""
    # Connect
    if account.acctType == "local":
        writeLog("Open local account")
        mailboxScreen = MboxScreen(win, account)

    elif account.acctType == "imap":
        writeLog("Open imap account")
        mailboxScreen = ImapMboxScreen(win, account)

    else:
        writeLog("Unknown account type: " + account.acctType)
        return

    if not mailboxScreen.connect():
        writeLog("connect failed")
        return
    ic = mailboxScreen.display()

class MailboxScreen(object):
    """Manages the mailbox selection dialog. Meant to be subclassed
    for the various types of mailboxes. Currently only supports
    Berkeley mbox and imap."""
    HELP_TOP = u"""Select the mailbox to read."""
    HELP_BOTTOM = """
More commands:

 +             add mailbox
 -             delete currently-selected mailbox
 q             return to account selection
 x             same

 /regex/        search for items matching regex"""

    def __init__(self, win, account):
        """Depending on account type, connect to server and then display
        list of mailboxes. If user selects 'q', this function reutrns."""
        self.win = win
        self.account = account

    def connect(self):
        """Connect to account and retrieve list of mailboxes."""
        self.account.connect()
        self.mboxes = self.account.getMboxes()
        return True

    def screenSetup(self):
        """Create appropriate OptionScreen object."""

        self.optScreen = optScreen = screens.ActiveOptionScreen(self.win,
            self.mboxes, "Select mailbox",
            (("?  Help", "CR Select"), ("↑ p Prev", "↓ n Next"),
                ("PGUP < PrevPage", "PGDN > NextPage"), ("HOME ^ Top", "END  $ Bottom"),
                ("+ Add", "- Remove")),
            "+-")
        optScreen.resize()
        optScreen.setTopPrompt("Select mailbox. %d/%d, F1 or ? for help: " % \
            (optScreen.getCurrent()+1, len(self.mboxes)))

    def display(self):
        # Display mailboxes and ask user to choose.
        self.screenSetup()
        optScreen = self.optScreen
        win = self.win
        mboxes = self.mboxes
        optScreen.display()
        writeLog("About to enter mailbox loop")
        while True:
            ic = win.getch()
            writeLog("Received character %d" % ic)
            if self.handleKey(ic):
                # handleKey() may have changed something, so re-read these
                optScreen = self.optScreen
                win = self.win
                mboxes = self.mboxes
                continue
            if ic in (ord('q'), ord('x'), ESC):
                self.account.disconnect()
                return ic
            if ic in (ord('?'), curses.KEY_F1):
                self.showHelp()
                continue
            if optScreen.commonKeys(ic):
                optScreen.setTopPrompt("Select mailbox. %d/%d, F1 or ? for help: " % \
                    (optScreen.getCurrent()+1, len(mboxes)))
                optScreen.refresh()
                continue
            idx = optScreen.isOptionKey(ic)
            if idx >= 0:
                # Launch next window
                MessageScreen(win, self.account, mboxes[idx])
                self.screenSetup()
                optScreen = self.optScreen
                optScreen.display()
                continue
            writeLog("Ignoring key code %d" % ic)

    def handleKey(self, ic):
        """handle keys not handled by display(). Return True if handled here"""
        return False

    def showHelp(self):
        hlp = self.HELP_TOP + COMMON_HELP + self.HELP_BOTTOM
        HelpScreen(self.win, hlp)
        self.optScreen.display()

    def emailScreen(self, win, mbox):
        return


class MboxScreen(MailboxScreen):
    """Support for Berkeley mbox email."""
    pass

class ImapMboxScreen(MailboxScreen):
    """Support for imap."""
    HELP_BOTTOM = u"""
 A             show all mailboxes, including unsubscribed
 S             manage subscribed mailboxes
 +             add mailbox
 -             delete currently-selected mailbox
 q             return to account selection
 x             same

 /regex/        search for items matching regex"""

    def connect(self):
        """Connect to account and retrieve list of mailboxes."""
        if not self.__imapLogin():
            return False
        self.mboxes = self.account.getMboxes()
        return True

    def screenSetup(self):
        """Create appropriate OptionScreen object."""
        long_cmds = ["A toggle view all mailboxes", "S manage subscribed mailboxes",
            "+ add mailbox", "- delete selected mailbox"]

        writeLog("Create new options screen, %d items" % len(self.mboxes))
        self.optScreen = optScreen = screens.ActiveOptionScreen(self.win, self.mboxes,
            "Select mailbox",
            "choose: ",
            "help",
            "ASNP+-",
            long_cmds)
        optScreen.resize()
        self.__bottomPrompt()

    def handleKey(self, ic):
        """handle keys not recognized by display(). Return True if handled here"""
        # TODO: S key
        if ic == ord('A'):
            self.account.subbedOnly = not self.account.subbedOnly
            self.mboxes = self.account.getMboxes()
            self.optScreen.setOptions(self.mboxes).displayOpts()
            self.__bottomPrompt()
            self.optScreen.refresh()
            return True
        return False

    def showHelp(self):
        hlp = self.HELP_TOP + COMMON_HELP + self.HELP_BOTTOM
        HelpScreen(self.win, hlp)
        self.optScreen.display()

    def __imapLogin(self):
        win = self.win
        account = self.account
        win.erase()
        win.addstr(1,1, "Opening account \"%s\"" % account.name)
        win.refresh()
        # Attempt to connect. Keep going until user enters a valid password
        # or hits ^C
        needPw = account.needsPasswd()
        while True:
            if needPw:
                pwWin = screens.passwordWindow(win)
                pwWin.display("Enter password, ^C to cancel:")
                pw = pwWin.read()
                win.move(2,1)
                win.clrtoeol()
                writeLog('Received string "%s"' % pw)
                pwWin = None
                win.refresh()
                if pw == None:
                    writeLog("pw was None, returning")
                    return False
                account.setPasswd(pw)
            try:
                win.addstr(2,1, "Logging in ...")
                win.refresh()
                account.connect()
            except imap.imapAuthFailed as e:
                win.addstr(2,1, "Authentication failed, try again")
                win.refresh()
                needPw = True
                continue
            except Exception as e:
                writeLog("Login failed: %s" % e)
                raise
            else:
                break
        writeLog("login successful")
        return True

    def __bottomPrompt(self):
        self.optScreen.setTopPrompt("Select mailbox. %d/%d, F1 or ? for help: " % \
            (self.optScreen.getCurrent()+1, len(self.mboxes)))



#       MESSAGE SELECTION

MESSAGE_HELP_TOP = u"""Select the message to read."""
MESSAGE_HELP_BOTTOM = u"""
 q             commit changes, return to mailbox selection
 x             return without saving changes

 N             next unread
 ^N            next unread with same subject
 P             previous unread
 ^P            previous unread with same subject

 d             delete/undelete current email %s
 D             toggle display of deleted messages
 m             mark as read
 M             mark entire thread as read
 u             mark as unread
 U             mark entire thread as unread
 !             mark or unmark as important
 S             set selector order
 t             toggle threaded view (TODO)
 →  +          expand selected thread (TODO)
 ←  -          unexpand selected thread (TODO)
 ^R            refresh mailbox - resume reading mailbox (can take a while)
 /             search, see below

Flags:

 !      flagged important
 N      new message
 U      unread message
 D      marked for deletion
 A      answered
 F      forwarded

Search:

 /regex/[modifiers][:cmd:cmd…]        search for messages matching regex

    modifiers; zero or more of:
        s       search Subject line (default if no modifiers specified)
        f       search From line
        t       search To line
        h       search all headers (potentially slow)
        b       search entire body (potentially very slow)

    search commands: zero or more of:
        :d       delete
        :m       move to INBOX
        :m box   move to specified mailbox
        :a file  append to file
        :| cmd   pipe through shell command

    With no commands, switches to a view of only matching articles.
    Use "/<cr>" to clear the filter and view everything again."""

SORT_HELP = """
Choose sort order from these options:
  s  subject
  S  subject, reverse order
  f  from
  F  from, reverse order
  t  to
  T  To, reverse order
  d  date, oldest first
  D  date, newest first

You can enter more than one letter, e.g. "sD" sorts messages alphabetically
by subject, then by date.

Blank line for unsorted (natural order of messages in mailbox).
^C to cancel."""

messageStart = False

class ViewOptions(object):
    def __init__(self):
        self.sortOrder = None
        self.showDeleted = False

def MessageScreen(win, account, mbox):
    """Prompt user to select a message. When the user selects one,
    go to DisplayScreen().  If user selects 'x' or 'q', this function
    returns."""
    global messageStart

    # Display the message selection screen with whatever messages
    # we already have, then start fetching more.

    viewOpts = ViewOptions()

    optScreen = MessageScreenSetup(win, account, mbox, [])
    optScreen.setBusy(True)
    optScreen.display()

    # If returning to a mailbox that's been loaded, even if only
    # partially, display it right away.
    summaries = FilterSummaries(mbox, viewOpts)
    if summaries:
        MessageScreenPrompt(optScreen, mbox)
        optScreen.setContent(summaries)
        optScreen.refresh()

    MessageScreenFetchEmail(optScreen, mbox, viewOpts)

    summaries = FilterSummaries(mbox, viewOpts)

    writeLog("About to enter MessageScreen main loop")
    oldUpdate = None
    while True:
        ic = win.getch()
        optScreen.setStatus("").refresh()
        writeLog("Received character %d" % ic)
        c = chr(ic) if ic < 128 else None
        # Before proceeding, check for changes
        update = mbox.checkForUpdates()
        if update != oldUpdate:
            oldUpdate = update
            if update == mbox.BOX_APPENDED:
                writeLog("update=%d, state=%d" % (update, mbox.state))
                if mbox.state == mbox.STATE_FINISHED:
                    # If the mbox state was FINISHED, then a) the user
                    # was happy to let it complete loading, and b) there
                    # probably isn't much more to load. So in this case,
                    # we go ahead and start loading again.
                    optScreen.setStatus("More email has arrived.").refresh()
                    MessageScreenFetchEmail(optScreen, mbox, viewOpts)
                else:
                    # Just inform the user
                    optScreen.setStatus("More email has arrived, ^R to update.").refresh()
            elif update == mbox.BOX_CHANGED:
                # For an mbox mailbox, a full re-read is required. Inform the user.
                # TODO: wipe out the existing message list? Start loading?
                optScreen.setStatus("Mailbox has been modified. ^R to re-load.").refresh()
        if c == 'q':
            if mbox.modified:
                writeLog("TODO: write out changes")
            return ic
        if ic in (ord('x'), ESC):
            return ic
        if ic in (ord('?'), curses.KEY_F1):
            helpStr = MESSAGE_HELP_TOP + COMMON_HELP + MESSAGE_HELP_BOTTOM
            HelpScreen(win, helpStr % ("(move to Trash)" if not mbox.isTrash() else "permanently"))
            optScreen.display()
            continue
        if c == 'N':
            idx = mbox.nextUnread(optScreen.getCurrent(), summaries)
            if idx is not None:
                optScreen.moveTo(idx)
                MessageScreenPrompt(optScreen, mbox)
            else:
                optScreen.setStatus("At last unread message").refresh()
            continue
        if c == 'P':
            idx = mbox.previousUnread(optScreen.getCurrent(), summaries)
            if idx is not None:
                optScreen.moveTo(idx)
                MessageScreenPrompt(optScreen, mbox)
            else:
                optScreen.setStatus("At first unread message").refresh()
            continue
        # If mailbox has changed, then none of the functions that would modify
        # or view it are valid. Catch those cases and tell the user to
        # refresh.
        if mbox.updates == mbox.BOX_CHANGED and c in 'dDmMuU/':
            writeLog("cannot execute command '%c'" % c)
            optScreen.setStatus("Mailbox reload required. ^R to re-load.").refresh()
            continue
        if c == 'd':
            idx = optScreen.getCurrent()
            writeLog("delete: idx = %d, direction = %d" % (idx, optScreen.direction))
            mbox.chFlags(summaries[idx].idx, 0, 0, messageSummary.FLAG_DELETED)
            if not viewOpts.showDeleted:
                del summaries[idx]
                optScreen.setContent(summaries)
                if optScreen.direction == -1: idx = mbox.previousMessage(idx, summaries)
                elif idx >= len(summaries): idx -= 1
            else:
                optScreen.displayContent(idx - optScreen.getOffset()).refresh()
                if optScreen.direction == -1: idx = mbox.previousMessage(idx, summaries)
                else: idx = mbox.nextMessage(idx, summaries)
            optScreen.moveTo(idx)
            optScreen.refresh()
            MessageScreenPrompt(optScreen, mbox)
            continue
        if c == 'D':
            viewOpts.showDeleted = not viewOpts.showDeleted
            summaries = FilterSummaries(mbox, viewOpts)
            optScreen.setContent(summaries)
            optScreen.setStatus("%s deleted messages" % ("Show" if viewOpts.showDeleted else "Don't show"))
            optScreen.refresh()
            # TODO: keep the current message current
            continue
        if c == 'S':
            sortorder = screens.simpleDiagWindow(win, hgt=20).display(SORT_HELP).read()
            # Note the current message
            row = optScreen.getRow()
            msg = summaries[optScreen.getCurrent()]
            viewOpts.sortOrder = filter(lambda c: c in "sSfFtTdD", sortorder)
            summaries = FilterSummaries(mbox, viewOpts)
            optScreen.setContent(summaries)
            optScreen.setCurrent(msg.client, row)
            MessageScreenPrompt(optScreen, mbox)
            optScreen.subwin.clear()
            optScreen.displayContent()
            optScreen.setStatus("Sort order %s" % (viewOpts.sortOrder or "natural"))
            optScreen.refresh()
            # TODO: keep the current message current
            continue
        if c == 'm':
            idx = optScreen.getCurrent()
            mbox.chFlags(idx, messageSummary.FLAG_READ, 0)
            optScreen.displayContent(idx - optScreen.getOffset()).refresh()
            MessageScreenPrompt(optScreen, mbox)
            continue
        if c == 'u':
            idx = optScreen.getCurrent()
            mbox.chFlags(idx, 0, messageSummary.FLAG_READ)
            optScreen.displayContent(idx - optScreen.getOffset()).refresh()
            MessageScreenPrompt(optScreen, mbox)
            continue
        if c == '!':
            idx = optScreen.getCurrent()
            mbox.chFlags(idx, 0, 0, messageSummary.FLAG_FLAGGED)
            optScreen.displayContent(idx - optScreen.getOffset()).refresh()
            MessageScreenPrompt(optScreen, mbox)
            continue
        # TODO: D,m,M,S,t,u
# D             delete entire thread
# M             mark entire thread as read
# t             toggle threaded view (TODO)
# +             expand selected thread (TODO)
# -             unexpand selected thread (TODO)
# ^R            refresh view - re-read mailbox (can take a while)
# /             search, see below

        if ic == CTRL_R:
            MessageScreenFetchEmail(optScreen, mbox, viewOpts)
            optScreen.setStatus("")
            continue
        if ic == CTRL_L:
            optScreen.display().refresh()
            continue
        if optScreen.commonKeys(ic):
            MessageScreenPrompt(optScreen, mbox)
            optScreen.refresh()
            continue
        idx = optScreen.isOptionKey(ic)
        if idx >= 0:
            # Read one or more messages
            if mbox.updates == mbox.BOX_CHANGED:
                writeLog("cannot view message '%d'" % idx)
                optScreen.setStatus("Mailbox changed; reload required. ^R to re-load.").refresh()
                continue
            writeLog("Chose option %d" % idx)
            newIdx = idx
            while idx is not None:
                # Launch email viewer
                ic = EmailScreen(win, account, mbox, summaries, idx)
                c = chr(ic) if ic < 128 else '\0'
                if c == 'n':
                    idx = mbox.nextMessage(idx)
                    optScreen.setCurrent(idx)
                elif c == 'p':
                    idx = mbox.previousMessage(idx)
                    optScreen.setCurrent(idx)
                elif c == 'N':
                    idx = mbox.nextUnread(idx)
                    optScreen.setCurrent(idx)
                elif c == 'P':
                    idx = mbox.previousUnread(idx)
                    optScreen.setCurrent(idx)
                elif c == 'd':
                    # TODO: don't delete quite yet; mark as deleted and
                    # process when the user is done reading messages.
                    summary = mbox.getSummary(idx)
                    mbox.delSummary(idx)
                    if optScreen.direction == -1: idx = mbox.previousMessage(idx)
                    elif idx >= mbox.nmessages(): idx -= 1
                    if idx is None: idx = 0
                    optScreen.setCurrent(idx)
                else:
                    idx = None
                if idx is not None: newIdx = idx
                #writeLog("New idx = %s" % idx)
            idx = newIdx
            optScreen.resize().setCurrent(idx)
            MessageScreenPrompt(optScreen, mbox)
            optScreen.display()
            continue
        writeLog("Ignoring key code %d" % ic)

def MessageScreenSetup(win, account, mbox, summaries):
    optScreen = MessageOptionScreen(win, summaries, mbox.name,
        (("?  Help", "CR Select"), ("↑ p Prev", "↓ n Next"),
            ("N Next Unread", "P Prev Unread"),
            ("PGUP < PrevPage", "PGDN > NextPage"), ("HOME ^ Top", "END  $ Bottom"),
            ("d Delete", ""), ("q Return", "x Abort")),
        "NPdDmMuUSt")
    optScreen.resize()
    MessageScreenPrompt(optScreen, mbox)
    return optScreen

def MessageScreenPrompt(optScreen, mbox, comment=None):
    topPrompt = ["%s   %d messages" % (mbox.name, mbox.nmessages())]
    if mbox.nNew is not None: topPrompt.append(", %d new" % mbox.nNew)
    if mbox.nUnread is not None: topPrompt.append(", %d unread" % mbox.nUnread)
    topPrompt.append(": %d/%d, " % (optScreen.getCurrent()+1, mbox.nmessages()))
    topPrompt.append(comment if comment else "F1 or ? for help: ")
    optScreen.setTopPrompt("".join(topPrompt))

def MessageScreenFetchEmail(optScreen, mbox, viewOpts):
    global messageStart
    messageStart = False

    optScreen.setBusy(True).refresh()

    # This step can take a long time for a very large mailbox.
    # The lambda is called every half second or so with a status
    # update. TODO: run this in a background thread.
    status = mbox.getOverview(lambda mbox,count,final,pct,msg: \
        MessageShowUpdate(optScreen, mbox, viewOpts, count, final, pct, msg))

    MessageScreenPrompt(optScreen, mbox)
    optScreen.setContent(FilterSummaries(mbox, viewOpts))
    optScreen.setBusy(False).refresh()

def FilterSummaries(mbox, viewOpts):
    """Make a copy of the summaries list in this mailbox, removing
    deleted items, and sorting."""
    summaries = mbox.summaries()
    for msg in summaries: msg.client = None
    if not summaries: return summaries
    if viewOpts.showDeleted:
        summaries = summaries[:]
    else:
        summaries = filter(lambda m: not (m.status & m.FLAG_DELETED), summaries)

    # TODO: If all the characters in sortOrder are upper case, or all are
    # lower case, we could do this all in one pass by passing multiple keys
    # to attrgetter.
    sortOrder = viewOpts.sortOrder
    if sortOrder:
        sortOrder = reversed(sortOrder)
        for c in sortOrder:
            if c in "Ss":
                summaries.sort(key=operator.attrgetter("Subject"), reverse=(c=='S'))
            elif c in "Ff":
                summaries.sort(key=operator.attrgetter("From"), reverse=(c=='F'))
            elif c in "Tt":
                summaries.sort(key=operator.attrgetter("To"), reverse=(c=='T'))
            elif c in "Dd":
                summaries.sort(key=operator.attrgetter("udate"), reverse=(c=='D'))
    for i,msg in enumerate(summaries): msg.client = i
    return summaries

def MessageShowUpdate(optScreen, mbox, viewOpts, count, pct, status, msg):
    # If this is called with final=False, then it's a good bet that
    # we're going to be here for a while, so time to start showing status
    global messageStart
    if msg:
        writeLog(msg)
        optScreen.setStatus(msg).refresh()
    if status == mbox.STATE_READING:
        if not messageStart:
            optScreen.setContent(FilterSummaries(mbox, viewOpts))
        MessageScreenPrompt(optScreen, mbox, "%d%%. ^C to interrupt" % pct)
        optScreen.refresh()

class MessageOptionScreen(screens.ColumnOptionScreen):
    def resizeColumns(self, wid):
        def setCwids(wids):
            self.cwidths = [(0,3)]
            col = 4
            for wid in wids:
                self.cwidths.append((col, wid))
                col += wid + 2
        if wid > 100:
            datewid = 16
            sizewid = 6
            wid -= 16+6
            wid -= 12            # column gaps
            subjwid = int(wid * 0.6)
            fromwid = wid - subjwid
            setCwids((subjwid, fromwid, datewid, sizewid))
        elif wid > 80:
            datewid = 16
            wid -= 16
            wid -= 10            # column gaps
            subjwid = int(wid * 0.6)
            fromwid = wid - subjwid
            setCwids((subjwid, fromwid, datewid))
        else:
            wid -= 8            # column gaps
            subjwid = int(wid * 0.6)
            fromwid = wid - subjwid
            setCwids((subjwid, fromwid))


#       MESSAGE VIEWER

EMAIL_HELP = u"""
Email message viewer:

 F1 ?          this text
 ↓ j           down one line
 ↑ k           up one line
 PGDN > ^F SP  next page
 PGUP < ^B     previous page
 HOME ^        top
 END  $        end
 ^L            refresh screen
 ^C            exit trm
 q ESC         return to previous screen
 x             return to previous screen without saving changes

 H             toggle full header view

 n             next message
 p             previous message
 N             next unread
 ^N            next unread with same subject
 P             previous unread
 ^P            previous unread with same subject

 d             delete current email %s
 D             delete entire thread
 m             mark as read
 M             mark entire thread as read
 u             mark as unread
 U             mark entire thread as unread"""

def EmailScreen(win, account, mbox, summaries, idx):
    """Display the selected message."""

    summary = summaries[idx]
    msg = summary.getMessage(mbox)
    # TODO: handle not found
    # If multipart, search for a text/plain part
    longHeaders = False
    if msg.is_multipart():
        charset = None
        text = None
        html = None
        for part in msg.walk():
            if part.is_multipart():
                continue
            if part.get_param("text/html") is not None:
                # We can use html if plain is not found
                charset = part.get_param("charset")
                text = part.get_payload(decode=True)
            if part.get_param("text/plain") is not None:
                # Found it
                charset = part.get_param("charset")
                text = part.get_payload(decode=True)
                break
    else:
        charset = msg.get_param("charset")
        text = msg.get_payload(decode=True)

    if not text: text = html
    if not text: text = u"No plain text found for this message"
    if charset:
        try:
            text = text.decode(charset, errors="replace")
        except LookupError:
            pass

    optScreen = EmailScreenSetup(win, account, mbox, idx, msg, text, longHeaders)
    optScreen.display()

    writeLog("About to enter EmailScreen main loop")
    while True:
        ic = win.getch()
        writeLog("Received character %d" % ic)
        c = chr(ic) if ic < 128 else None
        if c == 'q':
            mbox.chFlags(idx, messageSummary.FLAG_READ, 0)
            # Nothing is actually written until the user closes the mailbox.
            return ic
        if ic in (ord('x'), ESC):
            return ic
        if ic in (ord('?'), curses.KEY_F1):
            HelpScreen(win, EMAIL_HELP % ("(move to Trash)" if not mbox.isTrash() else "permanently"))
            optScreen = EmailScreenSetup(win, account, mbox, idx, msg, text, longHeaders)
            optScreen.display()
            continue
        if c == 'H':
            longHeaders = not longHeaders
            optScreen.setContent(EmailContent(msg, text, longHeaders)).refresh()
            continue
        if c in "npNPdD":
            mbox.chFlags(idx, messageSummary.FLAG_READ, 0)
            return ic
        # TODO: m,M,S,t,u
        if optScreen.commonKeys(ic):
            optScreen.refresh()
            continue
        writeLog("Ignoring key code %d" % ic)
        # TODO: detect changes

def EmailScreenSetup(win, account, mbox, idx, msg, text, longHeaders):
    optScreen = screens.PagerScreen(win, EmailContent(msg, text, longHeaders),
        "Message %d/%d" % (idx+1, mbox.nmessages()),
        (("? Help","d Delete"), ("↑ Up one", "↓ Down one"),
            ("PGUP < Page up", "PGDN > Page down"),
            ("HOME ^ Top", "END  $ Bottom"),
            ("n Next msg", "p Prev msg"), ("N Next unread", "P Prev unread"),
            ("q Return", "x Abort")))
    optScreen.resize().display()
    return optScreen

def EmailContent(msg, text, longHeaders):
    headers = []
    if not longHeaders:
        if "From" in msg: headers.append(u"From: " + parseIso(msg["From"]))
        if "Subject" in msg: headers.append(u"Subject: " + parseIso(msg["Subject"]))
        if "To" in msg: headers.append(u"To: " + parseIso(msg["To"]))
        if "Date" in msg: headers.append(u"Date: " + parseIso(msg["Date"]))
    else:
        for hdr in msg.keys():
            headers.append(unicode(hdr) + ": " + parseIso(msg[hdr]))
    return u"\n".join(headers) + u'\n\n' + unescape(text)


#       UTILITIES

def SecurityCheck(rcfile):
    try:
        sb = os.stat(rcfile)
    except OSError:
        return

    # Should be read-write to owner only.
    mode = stat.S_IMODE(sb.st_mode)
    if mode & 0177:
        if mode & 066:
            print("\n\n\nWarning: file \"%s\" was readable or writeable" % rcfile)
            print("by others (mode %o)" % mode)
            print("\nThis has been changed to mode 0600 (rw-------) for security.")
            print("If you had any passwords stored in this file,")
            print("you should consider changing them.")
        try:
            os.chmod(rcfile, 0600)
        except Exception as e:
            print('Failed to change mode of "%s" to %o, %s"' % (rcfile, 0600, e), file=sys.stderr)
        if mode & 066:
            raw_input("\nHit enter to continue: ")

def ReadConfig(rcfile, mailrc):
    config = configparser.ConfigParser()
    if os.path.isfile(rcfile):
        try:
            config.read(rcfile)
        except:
            pass
    if not config.has_section("global"):
        config.add_section("global")
        config.set("global","splashscreen", "0")

    # Read the old .mailrc file while we're here
    if os.path.isfile(mailrc):
        try:
            with open(mailrc, "r") as ifile:
                if not config.has_section("mailrc"):
                    config.add_section("mailrc")
                # Looking for "folder" variable.
                for line in ifile:
                    line = line.strip()
                    if line.startswith('#'): continue
                    mo = set_re.match(line)
                    if mo:
                        if mo.group(1) == "folder":
                            config.set("mailrc", "folder", mo.group(2).strip('"'))
        except Exception as e:
            print("Failed to read \"%s\", %s, ignored" % (mailrc, e), file=sys.stderr)

    return config

def WriteConfig(config, rcfile):
    try:
        config.remove_section("mailrc")
        config.write(open(rcfile,"w"))
    except Exception as e:
        print("Failed to write \"%s\"," % rcfile, e, file=sys.stderr)

def getAccounts(config):
    accounts = []
    getLocalAccount(accounts)
    for section in config.sections():
        if section.startswith("account "):
            name = section[8:].strip('"')
            config.set(section, "name", name)
            accounts.append(imap.imapAccount(name, section, config))
    return accounts

set_re = re.compile(r""" *set +(\w+)=(.+)""")   # For parsing .mailrc
def getLocalAccount(accounts):
    """Check for the presence of email on the local machine."""
    def getUserMail():
        path = os.path.join("/var/mail", os.environ["USER"])
        if os.path.isfile(path): return path
        path = os.path.join("/var/spool/mail", os.environ["USER"])
        if os.path.isfile(path): return path
        return None
    if "USER" in os.environ:
        userMail = getUserMail()
        writeLog("userMail = %s" % userMail)
        if userMail:
            # Where will user keep their local mail?
            if config.has_option("mailrc", "folder"):
                folder = config.get("mailrc", "folder")
                if not folder.startswith('/'):
                    folder = os.path.join(HOME, folder)
                    config.set("mailrc", "folder", folder)
                    writeLog("folder = %s" % folder)
            elif os.path.isdir(os.path.join(HOME, "mail")):
                configSet(config, "mailrc", "folder", os.path.join(HOME, "mail"))

            account = mbox.MboxAccount("local", userMail, config)
            accounts.append(account)

def percent(a,b):
    return 100*a//(b-1) if b > 1 else 100


if __name__ == '__main__':
    signal.signal(signal.SIGPIPE, signal.SIG_DFL)
    signal.signal(signal.SIGTSTP, signal.SIG_IGN)
    sys.exit(main())
