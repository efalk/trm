#!/usr/bin/env python
# -*- coding: utf8 -*-

from __future__ import print_function

usage = """First sentence is the short summary.

This program blah blah blah
for about a paragraph.

Usage:  trm [options] [account]

        -h, --help              this text
        -V, --version           print version and exit
        --rcfile <file>         trm rcfile, overriding ~/.trmrc

        account         identifies the mail server

Exit codes:

        0 - successful return
        2 - user error
        3 - system error, e.g. unable to connect to server

        TRMRC           trm rcfile path, overriding ~/.trmrc
"""

import curses
import errno
import getopt
import operator
import os
import re
import signal
import stat
import string
import sys
import time

import forms
from forms import keystr, getUchar
import screens
import emailaccount
import mbox
import imap
import imapform
from emailaccount import messageSummary
from emailaccount import parseIso
from keycodes import *
from utils import writeLog, loggingEnabled, configGet, configSet, toUtf

PY3 = sys.version_info[0] >= 3
if PY3:
    import configparser
    from html import unescape
    unicode = str
    basestring = str
    raw_input = input
else:
    import ConfigParser as configparser
    import locale
    import HTMLParser
    locale.setlocale(locale.LC_ALL, '')
    parser = HTMLParser.HTMLParser()
    unescape = parser.unescape

# Programming note: under Python2, curses knows nothing about unicode.
# You must manually encode any unicode string before passing to curses.
# See https://stackoverflow.com/a/40082903/338479

VERSION = "1.0"

SPLASH_SCREEN = """
                *** NEWS NEWS ***

        Welcome to trm 1.0 (19 April 2023).

        Type '?' or F1 at any prompt to get help.

        This message will not be displayed again unless it is updated with new
        information.

        Edward Falk falk@efalk.org

        [Type '?' for long help, or any other key to continue]
"""

MAIN_HELP = u"""
This is a relatively simple text-based mail reader. For far more
sophisticated mail readers, see PINE or MUTT. This one is written
to provide specific search and threading capabilities.

Navigating through help:

  ↑     up one line
  ↓     down one line
  PGUP  up one page
  PGDN  down one page
  HOME  back to top
  END   go to end
  q     return to previous screen

There are four main screens in trm:

• Account selection
• Mailbox selection
• Message selection
• Message reading

More on these modes below.


Navigation and other common operations:

Trm uses single-key commands in most cases. Navigation can go very quickly.
The following commands are available in all modes. In many cases, there is
more than one key for the same operation:

  F1    ?          F1 or '?' give helps from any page.
  q                "quit". Write out changes and return to previous page
  x                "exit". Return to previous page immediately without writing anything
  ↑     p          "Previous": up-arrow or 'p' moves up one line
  ↓     n          "Next": down-arrow or 'n' moves down one line
  PGUP  <  ^B      Back one page
  PGDN  >  ^F  SP  Forward one page
  HOME  ^          Go to top
  END   $          Go to end
  CR               select current item
  ^L               refresh screen
  ^C               exit trm
  ESC              return to previous screen (same as 'x')

  /                Begin a search.


Short help:

At the bottom of the screen you will see a summary of the most
commonly-used commands for the current mode. It looks something
like this:

    ?  Help      ↑ p Prev      PGUP < PrevPage    HOME ^ Top       + Add
    CR Select    ↓ n Next      PGDN > NextPage    END  $ Bottom    - Remove

There are usually more commands than this available, so use F1 or '?'
to see a more complete list.


More on the different modes:

• Account selection. In this screen, you select the email account
  you wish to read. By default, when you first start using trm,
  "local" is the only option. This refers to the email stored on
  your local system in /var/spool/mail or /var/mail (depending on OS).
  Even "local" won't be present if there is no mail on your
  system.

  The "+" key brings you to a dialog that allows you to add other
  email accounts to trm. At present, only IMAP is supported.

  Use the up/down arrow keys to highlight the account you want and
  hit ENTER, or just type the letter next to the account name to
  select it.

  Selecting an account brings you to:

• Mailbox selection. All of the available mailboxes for this account
  are displayed, with letters next to them. You can select any mailbox
  to read by typing the letter next to it, or by using the usual
  navigation keys to highlight a mailbox and then hitting CR.

• Message selection. Messages are displayed in the usual way. Use
  the navigation keys or type a letter to choose a message to be read.
  The 'S' command changes the sort criteria for the messages (default
  is unsorted - i.e. the order the messages happen to be stored).

  The 'n' and 'p' commands select the next or previous message,
  while 'N' and 'P' select the next or previous *unread* message.
  You can also use 'DEL' to delete a message, 'm' to mark it as read,
  'u' to mark it as unread, '!' to mark it as important, and so
  forth. Use '?' to get a full list of commands.

• Message reading. This mode simply displays a message. Use the
  navigation keys to scroll back and forth in the usual way.

  Trm doesn't handle attachments (yet). If the message contains a
  "text/plain" section, that is the part which is displayed. Else,
  a "text/html" section, if any.

  The 'n', 'p', 'N', 'P', 'd', 'm', 'u', and '!' commands also
  work in message reading mode. Use '?' for the full list of
  options.
"""


rcfile = None
mailrc = None
config = None
accounts = []

HOME = os.environ["HOME"] if "HOME" in os.environ else os.path.expanduser('~')

COMMON_HELP = u"""

Common commands:

 F1 ?          this text
 n ↓           next
 p ↑           previous
 ^E            scroll up 1 line
 PGDN > ^F SP  next page
 PGUP < ^B     previous page
 HOME ^        top
 END  $        end
 ^L            refresh screen
 ^C            exit trm
 ESC           return to previous screen

 CR            select current item
 a-zA-Z0-9     select indicated item
"""
# ^Y       scroll down 1 line           TODO terminal converts ^Y to SIGSTP


IMAP_HELP = u"""
 A      show all mailboxes, including unsubscribed
 S      edit subscriptions"""





#       MAIN


def main():
    """main() handles the initial setup before entering curses mode. It
    reads the config files, parses command line arguments, etc. It then
    runs main_func() which enters curses mode operations. main_func()
    is wrapped in a try/catch block that makes sure curses mode is exited
    no matter what happens."""
    global rcfile, mailrc, config, accounts

    term = None

    if "TRMRC" in os.environ:
        rcfile = os.environ["TRMRC"]
    else:
        rcfile = os.path.join(HOME, ".trmrc")

    if "MAILRC" in os.environ:
        mailrc = os.path.expanduser(os.environ["MAILRC"])
    else:
        mailrc = os.path.join(HOME, ".mailrc")

    # Get arguments with getopt
    long_opts = ['help', 'term=', 'rcfile=', 'version']
    try:
        (optlist, args) = getopt.getopt(sys.argv[1:], 'hVb:cL', long_opts)
        for flag, value in optlist:
            if flag in ('-h', "--help"):
                print(usage)
                return 0
            if flag in ('-V', "--version"):
                print("trm version " + VERSION)
                return 0
            elif flag == '-L':
                loggingEnabled = True
            elif flag == "--rcfile":
                rcfile = value
            elif flag == '-c':
                pass
            elif flag == '--term':
                term = value
    except getopt.GetoptError as e:
        print(e)
        sys.exit(2)

    SecurityCheck(rcfile)
    config = ReadConfig(rcfile, mailrc)

    accounts = getAccounts(config)

    if term:
        sys.stdin = open(term,"r")
        sys.stdout = open(term,"w")

    try:
        key = main_func(curses.initscr())

    except Exception as e:
        curses.endwin()
        print()
        print("trm died with:", e)
        raise
    except KeyboardInterrupt as e:
        curses.endwin()
        print()
        sys.exit(1)
    else:
        curses.endwin()
        if key != u'x':
            WriteConfig(config, rcfile)
        return 0

def main_func(stdscr):
    """This is the section that enters curses mode and calls the
    splash screen (if needed) and then goes to account selection mode."""
    curses.noecho()
    curses.cbreak()
    stdscr.keypad(True)

    SHORT_HELP = (("F1 ?  Help", "DEL delete 1 char", u"↑ BTAB Previous", "CR accept"),
                  ("F2 ^G Guess", "^U  delete all", u"↓ TAB  Next", "ESC cancel"))

    #dummytext = [u"This is line %d" % i for i in range(40)]
    #form = screens.ContentScreen(stdscr, dummytext, "ContentScreen", SHORT_HELP, "the status")
    #form.redraw().refresh()
    #key = form.wait()

    #form = screens.ContentScreen(stdscr, dummytext, "ContentScreen #2", SHORT_HELP, "the status")
    #form.redraw().refresh()
    #key = form.wait()

    #screens.HelpScreen(stdscr, ACCOUNT_SCREEN_HELP)
    #screens.HelpScreen(stdscr, MESSAGE_HELP_BOTTOM)

#    win = stdscr.derwin(40,80,4,4)
#    form = screens.Form(stdscr, win)
#    lbl1 = form.Label(form, 1,20,2,2, "a label")
#    cb1 = form.Checkbox(form, 1,0, 19,2, "Checkbox, press me")
#    sh1 = form.ShortHelp(form, None,None,None,None,
#            (("↑ Up one", "↓ Down one"), ("PGUP < Page up", "PGDN > Page down"),
#                ("HOME ^ Top", "END  $ Bottom"), ("q Exit help", "? long help")))
#    cb1.setCallback(lambda cb, client: sh1.enable(not sh1.enabled).refresh(), None)
#    widgets = [lbl1,
#        form.Label(form, 1,20,3,2, "another label, longer than the space alotted."),
#        form.Label(form, 2,20,4,2, u"third label\nwith °two lines"),
#        form.Text(form, 1,30, 7,2, u"Text field"),
#        form.Text(form, 3,30, 10,2, u"Text field"),
#        form.Button(form, 3,0, 15,2, "Button, press me"),
#        cb1,
#        sh1,
#        ]
#    form.setWidgets(widgets)
#    form.redraw().refresh()
#    key = form.wait()
#    writeLog("Ended with key %s" % key)
#    lbl1.set("Changed!").refresh()
#    key = form.wait()

    # Main loop.
    if configGet(config, "global","splashscreen") != VERSION:
        SplashScreen(stdscr)

    return AccountScreen(stdscr, accounts)


#       SPLASH SCREEN

def SplashScreen(win):
    global config
    if not os.path.isfile(rcfile):
        message = "Creating the file " + rcfile + "\n\n" + SPLASH_SCREEN
    else:
        message = SPLASH_SCREEN
    screen = screens.ShortMessage(win, message)
    c = screen.displayAndWait()
    config.set("global","splashscreen", VERSION)
    if c in (ord('?'), curses.KEY_F1):
        screens.HelpScreen(win, MAIN_HELP)


#       ACCOUNT SELECTION

ACCOUNT_SCREEN_HELP = u"""
Select the email account to read. "local" refers to email stored
locally on this machine, if any. Use '+' key to add a new
account.""" + COMMON_HELP + """
More commands:

 +             add account
 -             delete currently-selected account
 E             edit currently-selected account
 q             exit trm
 x             exit trm without saving settings"""

def AccountScreen(win, accounts):
    """Prompt user to select an account. When the user selects
    one, go to MailboxScreen().  If user selects 'q', this function
    returns."""
    global config

    optScreen = AccountScreenSetup(win, accounts)
    optScreen.redraw().refresh()
    writeLog("AccountScreen about to enter main loop")
    while True:
        key = optScreen.getUchar()
        idx = optScreen.isOptionKey(key)
        if idx is not None:
            writeLog("Chose option %d" % idx)
            DoMboxScreen(win, accounts[idx])
            optScreen.redraw().refresh()
            continue
        rval = optScreen.handleKey(key)
        writeLog(u"AccountScreen Received character %s, rval=%s" % (keystr(key), rval))
        if key in (u'q', u'x', ESC):
            return key
        if key in (u'?', curses.KEY_F1):
            screens.HelpScreen(win, ACCOUNT_SCREEN_HELP)
            optScreen.redraw()
            continue
        if rval is not None:
            current = optScreen.getCurrent()
            if current is None: current = 0
            optScreen.setTopPrompt("Select account. %d/%d, F1 or ? for help: " % \
                (current+1, len(accounts)))
            optScreen.refresh()
            continue
        if key == u'+':
            newEmail = imapform.getImapAccount(win)
            if newEmail:
                writeLog("imapForm returns %s" % newEmail)
                accounts.append(newEmail)
                sectName = 'account "%s"' % newEmail.name
                try:
                    config.add_section(sectName)
                    writeLog("new section %s" % sectName)
                    config.set(sectName, "imap", newEmail.host)
                    config.set(sectName, "imapport", newEmail.port)
                    config.set(sectName, "imapconn", newEmail.conn)
                    config.set(sectName, "imapuser", newEmail.user)
                    if newEmail.passwd:
                        config.set(sectName, "imappass", newEmail.passwd)
                    if newEmail.authtype:
                        config.set(sectName, "imapauth", newEmail.authtype)
                except Exception as e:
                    writeLog("Failed to set config: %s" % e)
                optScreen = AccountScreenSetup(win, accounts)
            optScreen.redraw().refresh()
            continue
        writeLog("Ignoring key code %s" % keystr(key))

def AccountScreenSetup(win, accounts):
    long_cmds = ["+ add email account", "- delete selected email account",
        "E edit selected email account"]
    # Commands:
    #  ?  Help       ↑ p Prev   PGUP < PrevPage  HOME ^ Top     + Add     E Edit
    #  CR Select     ↓ n Next   PGDN > NextPage  END  $ Bottom  - Remove

    optScreen = screens.OptionScreen(win, accounts, "Select email account",
        (("?  Help", "↑ p Prev", "PGUP < PrevPage", "HOME ^ Top", "+ Add", "E Edit"),
         ("CR Select", "↓ n Next", "PGDN > NextPage", "END  $ Bottom", "- Remove")),
        "E+-")
    optScreen.resize()
    current = optScreen.getCurrent()
    if current is None: current = 0
    optScreen.setTopPrompt("Select account. %d/%d, F1 or ? for help: " % \
        (current+1, len(accounts)))
    return optScreen



#       MAILBOX SELECTION

# PROGRAMMING NOTES:
#
# The behavior of the message selection screen varies depending on
# the mailbox type, so we use an object-oriented approach here.
# The actual working code is in class MailboxScreen or a subclass.
# The entry point to this mode, DoMboxScreen() chooses the
# correct subclass depending on mailbox type.

def DoMboxScreen(win, account):
    """Display and operate the mailbox selection screen. Most
    of the work is done in an MailboxScreen object."""
    # Connect
    if account.acctType == "local":
        writeLog("Open local account")
        mailboxScreen = MboxScreen(win, account)

    elif account.acctType == "imap":
        writeLog("Open imap account")
        mailboxScreen = ImapMboxScreen(win, account)

    else:
        writeLog("Unknown account type: " + account.acctType)
        return

    if not mailboxScreen.connect():
        writeLog("connect failed")
        return
    rval = mailboxScreen.wait()

class MailboxScreen(object):
    """Manages the mailbox selection dialog. Meant to be subclassed
    for the various types of mailboxes. Currently only supports
    Berkeley mbox and imap."""
    HELP_TOP = u"""Select the mailbox to read."""
    HELP_BOTTOM = """
More commands:

 +             add mailbox
 -             delete currently-selected mailbox
 q             return to account selection
 x             same

 /regex/        search for items matching regex"""

    def __init__(self, win, account):
        """Depending on account type, connect to server and then display
        list of mailboxes. If user selects 'q', this function reutrns."""
        self.win = win
        self.account = account

    def connect(self):
        """Connect to account and retrieve list of mailboxes."""
        self.account.connect()
        self.mboxes = self.account.getMboxes()
        return True

    def screenSetup(self):
        """Create appropriate OptionScreen object."""

        self.optScreen = optScreen = screens.ActiveOptionScreen(self.win,
            self.mboxes, "Select mailbox",
            (('?  Help', '↑ p Prev', 'PGUP < PrevPage', 'HOME ^ Top', '+ Add'),
             ('CR Select', '↓ n Next', 'PGDN > NextPage', 'END  $ Bottom', '- Remove')),
            "qx+-")
        optScreen.resize()
        current = optScreen.getCurrent()
        if current is None: current = 0
        optScreen.setTopPrompt("Select mailbox. %d/%d, F1 or ? for help: " % \
            (current+1, len(self.mboxes)))

    def wait(self):
        # Display mailboxes and ask user to choose.
        self.screenSetup()
        optScreen = self.optScreen
        win = self.win
        mboxes = self.mboxes
        optScreen.redraw().refresh()
        writeLog("About to enter mailbox loop")
        while True:
            key = getUchar(self.win)
            idx = optScreen.isOptionKey(key)
            writeLog("Received character %s, idx = %s" % (keystr(key),idx))
            if idx is not None:
                # Launch next window
                MessageSelectionScreen(win, self.account, mboxes[idx])
                # Returned from MessageSelectionScreen, set up the message selection screen again
                self.optScreen.redraw().refresh()
                continue
            rval = optScreen.handleKey(key)
            writeLog("Received character %s, handleKey returns %s" % (keystr(key),rval))
            if rval is not None:
                # handleKey() may have changed something, so re-read these
                optScreen = self.optScreen
                current = optScreen.getCurrent()
                if current is None: current = 0
                optScreen.setTopPrompt("Select mailbox. %d/%d, F1 or ? for help: " % \
                    (current+1, len(mboxes)))
                win = self.win
                mboxes = self.mboxes
                continue
            if key in (u'q', u'x', ESC):
                self.account.disconnect()
                return key
            if key in (u'?', curses.KEY_F1):
                self.showHelp()
                self.optScreen.refresh()
                continue
            writeLog("Ignoring key code %d" % key)

    def handleKey(self, key):
        return False

    def showHelp(self):
        hlp = self.HELP_TOP + COMMON_HELP + self.HELP_BOTTOM
        screens.HelpScreen(self.win, hlp)
        self.optScreen.redraw()

    def emailScreen(self, win, mbox):
        return


class MboxScreen(MailboxScreen):
    """Support for Berkeley mbox email."""
    pass

class ImapMboxScreen(MailboxScreen):
    """Support for imap."""
    HELP_BOTTOM = u"""
 A             show all mailboxes, including unsubscribed
 S             manage subscribed mailboxes
 +             add mailbox
 -             delete currently-selected mailbox
 q             return to account selection
 x             same

 /regex/        search for items matching regex"""

    def connect(self):
        """Connect to account and retrieve list of mailboxes."""
        if not self.__imapLogin():
            return False
        self.mboxes = self.account.getMboxes()
        return True

    def screenSetup(self):
        """Create appropriate OptionScreen object."""
        long_cmds = ["A toggle view all mailboxes", "S manage subscribed mailboxes",
            "+ add mailbox", "- delete selected mailbox"]

        writeLog("Create new options screen, %d items" % len(self.mboxes))
        self.optScreen = optScreen = screens.ActiveOptionScreen(self.win, self.mboxes,
            "Select mailbox",
            "choose: ",
            "help",
            "ASNP+-",
            long_cmds)
        optScreen.resize()
        self.__bottomPrompt()

    def handleKey(self, key):
        # TODO: S key
        if key == u'A':
            self.account.subbedOnly = not self.account.subbedOnly
            self.mboxes = self.account.getMboxes()
            self.optScreen.setOptions(self.mboxes).displayOpts()
            self.__bottomPrompt()
            self.optScreen.refresh()
            return True
        return False

    def showHelp(self):
        hlp = self.HELP_TOP + COMMON_HELP + self.HELP_BOTTOM
        screens.HelpScreen(self.win, hlp)
        self.optScreen.redraw()

    def __imapLogin(self):
        win = self.win
        account = self.account
        win.erase()
        win.addstr(1,1, "Opening account \"%s\"" % account.name)
        win.refresh()
        # Attempt to connect. Keep going until user enters a valid password
        # or hits ^C
        needPw = account.needsPasswd()
        while True:
            if needPw:
                pwWin = screens.passwordWindow(win)
                pwWin.redraw("Enter password, ^C to cancel:")
                pw = pwWin.read()
                win.move(2,1)
                win.clrtoeol()
                writeLog('Received string "%s"' % pw)
                pwWin = None
                win.refresh()
                if pw == None:
                    writeLog("pw was None, returning")
                    return False
                account.setPasswd(pw)
            try:
                win.addstr(2,1, "Logging in ...")
                win.refresh()
                account.connect()
            except imap.imapAuthFailed as e:
                win.addstr(2,1, "Authentication failed, try again")
                win.refresh()
                needPw = True
                continue
            except Exception as e:
                writeLog("Login failed: %s" % e)
                raise
            else:
                break
        writeLog("login successful")
        return True

    def __bottomPrompt(self):
        current = self.optScreen.getCurrent()
        if current is None: current = 0
        self.optScreen.setTopPrompt("Select mailbox. %d/%d, F1 or ? for help: " % \
            (current+1, len(self.mboxes)))



#       MESSAGE SELECTION

MESSAGE_HELP_TOP = u"""Select the message to read."""
MESSAGE_HELP_BOTTOM = u"""
 q             commit changes, return to mailbox selection
 x             return without saving changes

 N             next unread
 ^N            next unread with same subject
 P             previous unread
 ^P            previous unread with same subject

 d  DEL        delete/undelete current email %s
 D             toggle display of deleted messages
 m             mark as read
 M             mark entire thread as read
 u             mark as unread
 U             mark entire thread as unread
 !             mark or unmark as important
 S             set selector order
 t             toggle threaded view (TODO)
 →  +          expand selected thread (TODO)
 ←  -          unexpand selected thread (TODO)
 ^R            refresh mailbox - resume reading mailbox (can take a while)
 /             search, see below

Flags:

 !      flagged important
 N      new message
 U      unread message
 D      marked for deletion
 A      answered
 F      forwarded

Search:

 /regex/[modifiers][:cmd:cmd…]        search for messages matching regex

    modifiers; zero or more of:
        s       search Subject line (default if no modifiers specified)
        f       search From line
        t       search To line
        h       search all headers (potentially slow)
        b       search entire body (potentially very slow)

    search commands: zero or more of:
        :d       delete
        :m       move to INBOX
        :m box   move to specified mailbox
        :a file  append to file
        :| cmd   pipe through shell command

    With no commands, switches to a view of only matching articles.
    Use "/<cr>" to clear the filter and view everything again."""

SORT_HELP = """
Choose sort order from these options:
  s  subject
  S  subject, reverse order
  f  from
  F  from, reverse order
  t  to
  T  To, reverse order
  d  date, oldest first
  D  date, newest first

You can enter more than one letter, e.g. "sD" sorts messages alphabetically
by subject, then by date.

Blank line for unsorted (natural order of messages in mailbox).
^C to cancel."""

messageStart = False

class ViewOptions(object):
    def __init__(self):
        self.sortOrder = None
        self.showDeleted = False
    def __str__(self):
        return "<ViewOptions order=%s showDeleted=%s>" % (self.sortOrder, self.showDeleted)

def MessageSelectionScreen(win, account, mbox):
    """Prompt user to select a message. When the user selects one,
    go to DisplayScreen().  If user selects 'x' or 'q', this function
    returns."""
    global messageStart

    # Display the message selection screen with whatever messages
    # we already have, then start fetching more.

    viewOpts = ViewOptions()

    optScreen = MessageSelectionScreenSetup(win, account, mbox, [])
    optScreen.setBusy(True)
    optScreen.redraw().refresh()

    # If returning to a mailbox that's been loaded, even if only
    # partially, display it right away.
    summaries = FilterSummaries(mbox, viewOpts)
    if summaries:
        MessageSelectionScreenPrompt(optScreen, mbox)
        optScreen.setContent(summaries)
        optScreen.refresh()

    MessageSelectionScreenFetchEmail(optScreen, mbox, viewOpts)

    summaries = FilterSummaries(mbox, viewOpts)

    writeLog("MessageSelectionScreen about to enter main loop")
    oldUpdate = None
    while True:
        key = getUchar(win)
        optScreen.setStatus("")
        writeLog("Received character %s" % keystr(key))
        # Before proceeding, check for changes
        update = mbox.checkForUpdates()
        #writeLog("update=%s, oldUpdate=%s" % (update, oldUpdate))
        if update != oldUpdate:
            oldUpdate = update
            if update == mbox.BOX_APPENDED:
                writeLog("update=%d, state=%d" % (update, mbox.state))
                if mbox.state == mbox.STATE_FINISHED:
                    # If the mbox state was FINISHED, then a) the user
                    # was happy to let it complete loading, and b) there
                    # probably isn't much more to load. So in this case,
                    # we go ahead and start loading again.
                    optScreen.setStatus("More email has arrived.")
                    MessageSelectionScreenFetchEmail(optScreen, mbox, viewOpts)
                else:
                    # Just inform the user
                    optScreen.setStatus("More email has arrived, ^R to update.")
            elif update == mbox.BOX_CHANGED:
                # For an mbox mailbox, a full re-read is required. Inform the user.
                # TODO: wipe out the existing message list? Start loading?
                optScreen.setStatus("Mailbox has been modified. ^R to re-load.")

        # Check key for a command
        if key == u'q':         # quit
            if mbox.modified:
                writeLog("TODO: write out changes")
            return key
        if key in (u'x', ESC):  # exit
            return key
        if key in (u'?', curses.KEY_F1):
            helpStr = MESSAGE_HELP_TOP + COMMON_HELP + MESSAGE_HELP_BOTTOM
            screens.HelpScreen(win, helpStr % ("(move to Trash)" if not mbox.isTrash() else "permanently"))
            optScreen.redraw().refresh()
            continue
        if key == u'N':         # next unread
            current = optScreen.getCurrent()
            if current is not None:
                idx = mbox.nextUnread(current, summaries)
                if idx is not None:
                    optScreen.moveTo(idx)
                    MessageSelectionScreenPrompt(optScreen, mbox)
                else:
                    optScreen.setStatus("At last unread message")
            continue
        if key == 'P':          # previous unread
            current = optScreen.getCurrent()
            if current is not None:
                idx = mbox.previousUnread(current, summaries)
                if idx is not None:
                    optScreen.moveTo(idx)
                    MessageSelectionScreenPrompt(optScreen, mbox)
                else:
                    optScreen.setStatus("At first unread message")
            continue
        if key == CTRL_R:       # resume loading mailbox
            writeLog("MessageSelectionScreen ^R, call fetchemail")
            optScreen.setStatus("Resume loading")
            MessageSelectionScreenFetchEmail(optScreen, mbox, viewOpts)
            optScreen.setStatus("")
            continue
        # If mailbox has changed, then none of the functions that would modify
        # or view it are valid. All commands beyond this point are invalid.
        # until the user does a refresh.
        if mbox.updates == mbox.BOX_CHANGED:
            writeLog(u"cannot execute command '%s'" % keystr(key))
            optScreen.setStatus("Mailbox reload required. ^R to re-load.")
            continue
        else:
            if key in (curses.KEY_DC, u'd', u'177'):        # delete
                idx = optScreen.getCurrent()
                if idx is not None:
                    writeLog("delete: idx = %d, direction = %d" % (idx, optScreen.getDirection()))
                    mbox.chFlags(summaries[idx].idx, 0, 0, messageSummary.FLAG_DELETED)
                    if not viewOpts.showDeleted:
                        del summaries[idx]
                        optScreen.setContent(summaries)
                        if optScreen.getDirection() == -1: idx = mbox.previousMessage(idx, summaries)
                        elif idx >= len(summaries): idx -= 1
                    else:
                        optScreen.displayContent()
                        if optScreen.getDirection() == -1: idx = mbox.previousMessage(idx, summaries)
                        else: idx = mbox.nextMessage(idx, summaries)
                    optScreen.moveTo(idx)
                    optScreen.refresh()
                    MessageSelectionScreenPrompt(optScreen, mbox)
                continue
            if key == u'D':         # toggle view of deleted messages
                viewOpts.showDeleted = not viewOpts.showDeleted
                summaries = FilterSummaries(mbox, viewOpts)
                optScreen.setContent(summaries)
                optScreen.setStatus("%s deleted messages" % ("Show" if viewOpts.showDeleted else "Don't show"))
                optScreen.refresh()
                # TODO: keep the current message current
                continue
            if key == u'S':         # Change sort order
                sortorder = screens.simpleDiagWindow(win, hgt=20).display(SORT_HELP).read()
                current = optScreen.getCurrent()
                if current is not None:
                    # Note the current message
                    row = optScreen.getRow()
                    msg = summaries[current]
                    writeLog("Changing sort order. current row=%d, current item=%s" % (row, msg))
                    viewOpts.sortOrder = filter(lambda c: c in "sSfFtTdD", sortorder) if sortorder else None
                    summaries = FilterSummaries(mbox, viewOpts)
                    optScreen.setContent(summaries)
                    optScreen.setCurrent(msg.client, row)
                    MessageSelectionScreenPrompt(optScreen, mbox)
                optScreen.displayContent()
                optScreen.setStatus("Sort order %s" % (viewOpts.sortOrder or "natural"))
                optScreen.refresh()
                continue
            if key == u'm':         # mark read
                idx = optScreen.getCurrent()
                if idx is not None:
                    mbox.chFlags(idx, messageSummary.FLAG_READ, 0)
                    optScreen.displayContent(idx - optScreen.getScroll()).refresh()
                    MessageSelectionScreenPrompt(optScreen, mbox)
                continue
            if key == u'u':         # mark unread
                idx = optScreen.getCurrent()
                if idx is not None:
                    mbox.chFlags(idx, 0, messageSummary.FLAG_READ)
                    optScreen.displayContent(idx - optScreen.getScroll()).refresh()
                    MessageSelectionScreenPrompt(optScreen, mbox)
                continue
            if key == u'!':         # flag important
                idx = optScreen.getCurrent()
                if idx is not None:
                    mbox.chFlags(idx, 0, 0, messageSummary.FLAG_FLAGGED)
                    optScreen.displayContent(idx - optScreen.getScroll()).refresh()
                    MessageSelectionScreenPrompt(optScreen, mbox)
                continue
        # TODO: D,m,M,S,t,u
# D             delete entire thread
# M             mark entire thread as read
# t             toggle threaded view (TODO)
# +             expand selected thread (TODO)
# -             unexpand selected thread (TODO)
# ^R            refresh view - re-read mailbox (can take a while)
# /             search, see below

        idx = optScreen.isOptionKey(key)
        writeLog("message index = %s" % idx)
        if idx is not None:                 # User selected a message
            # Read one or more messages
            if mbox.updates == mbox.BOX_CHANGED:
                writeLog("cannot view message '%d'" % idx)
                optScreen.setStatus("Mailbox changed; reload required. ^R to re-load.").refresh()
                continue
            writeLog("Chose option %d" % idx)
            newIdx = idx
            while idx is not None:
                # Launch email viewer
                key = EmailScreen(win, account, mbox, summaries, idx)
                if key == u'n':
                    idx = mbox.nextMessage(idx)
                    optScreen.moveTo(idx)
                elif key == u'p':
                    idx = mbox.previousMessage(idx)
                    optScreen.moveTo(idx)
                elif key == u'N':
                    idx = mbox.nextUnread(idx)
                    optScreen.moveTo(idx)
                elif key == u'P':
                    idx = mbox.previousUnread(idx)
                    optScreen.moveTo(idx)
                elif key in (curses.KEY_DC, u'd', u'177'):
                    # TODO: don't delete quite yet; mark as deleted and
                    # process when the user is done reading messages.
                    summary = mbox.getSummary(idx)
                    mbox.delSummary(idx)
                    if optScreen.getDirection() == -1: idx = mbox.previousMessage(idx)
                    elif idx >= mbox.nmessages(): idx -= 1
                    if idx is None: idx = 0
                    optScreen.moveTo(idx)
                else:
                    idx = None
                if idx is not None: newIdx = idx
                #writeLog("New idx = %s" % idx)
            idx = newIdx
            optScreen.resize().moveTo(idx)
            MessageSelectionScreenPrompt(optScreen, mbox)
            optScreen.redraw().refresh()
            continue
        if optScreen.handleKey(key) is not None:            # Pass it to the form.
            MessageSelectionScreenPrompt(optScreen, mbox)
            continue
        writeLog("Ignoring key code %s" % keystr(key))

def MessageSelectionScreenSetup(win, account, mbox, summaries):
    optScreen = MessageOptionScreen(win, summaries, mbox.name,
        (("?  Help", "↑ p Prev", "N Next Unread", "PGUP < PrevPage", "HOME ^ Top", "d Delete", "q Return"),
         ("CR Select", "↓ n Next", "P Prev Unread", "PGDN > NextPage", "END  $ Bottom", "", "x Abort")),
        "NPdDmMuUSt", "")
    optScreen.resize().redraw().refresh()
    MessageSelectionScreenPrompt(optScreen, mbox)
    return optScreen

def MessageSelectionScreenPrompt(optScreen, mbox, comment=None):
    topPrompt = ["%s   %d messages" % (mbox.name, mbox.nmessages())]
    if mbox.nNew is not None: topPrompt.append(", %d new" % mbox.nNew)
    if mbox.nUnread is not None: topPrompt.append(", %d unread" % mbox.nUnread)
    current = optScreen.getCurrent()
    if current is None: current = 0
    topPrompt.append(": %d/%d, " % (current+1, mbox.nmessages()))
    topPrompt.append(comment if comment else "F1 or ? for help: ")
    optScreen.setTopPrompt("".join(topPrompt))

def MessageSelectionScreenFetchEmail(optScreen, mbox, viewOpts):
    global messageStart
    messageStart = False

    optScreen.setBusy(True).refresh()

    # This step can take a long time for a very large mailbox.
    # The lambda is called every half second or so with a status
    # update. TODO: run this in a background thread.
    writeLog("FetchEmail(optScreen, mbox=%s, viewOpts=%s)" % (mbox, viewOpts))
    status = mbox.getOverview(lambda mbox,count,final,pct,msg: \
        MessageShowUpdate(optScreen, mbox, viewOpts, count, final, pct, msg))

    MessageSelectionScreenPrompt(optScreen, mbox)
    optScreen.setContent(FilterSummaries(mbox, viewOpts))
    optScreen.setBusy(False).refresh()

def FilterSummaries(mbox, viewOpts):
    """Make a copy of the summaries list in this mailbox, removing
    deleted items, and sorting."""
    summaries = mbox.summaries()
    for msg in summaries: msg.client = None
    if not summaries: return summaries
    if viewOpts.showDeleted:
        summaries = summaries[:]
    else:
        summaries = filter(lambda m: not (m.status & m.FLAG_DELETED), summaries)

    # TODO: If all the characters in sortOrder are upper case, or all are
    # lower case, we could do this all in one pass by passing multiple keys
    # to attrgetter.
    sortOrder = viewOpts.sortOrder
    if sortOrder:
        sortOrder = reversed(sortOrder)
        for c in sortOrder:
            if c in "Ss":
                summaries.sort(key=operator.attrgetter("Subject"), reverse=(c=='S'))
            elif c in "Ff":
                summaries.sort(key=operator.attrgetter("From"), reverse=(c=='F'))
            elif c in "Tt":
                summaries.sort(key=operator.attrgetter("To"), reverse=(c=='T'))
            elif c in "Dd":
                summaries.sort(key=operator.attrgetter("udate"), reverse=(c=='D'))
    for i,msg in enumerate(summaries): msg.client = i
    return summaries

def MessageShowUpdate(optScreen, mbox, viewOpts, count, pct, status, msg):
    # If this is called with final=False, then it's a good bet that
    # we're going to be here for a while, so time to start showing status
    global messageStart
    if msg:
        writeLog(msg)
        optScreen.setStatus(msg).refresh()
    if status == mbox.STATE_READING:
        if not messageStart:
            optScreen.setContent(FilterSummaries(mbox, viewOpts))
        MessageSelectionScreenPrompt(optScreen, mbox, "%d%%. ^C to interrupt" % pct)
        optScreen.refresh()

class MessageOptionsList(forms.Form.ColumnOptionsList):
    def resizeColumns(self):
        """Fill in the cwidths list with (column,width) pairs.
        Columns start at 0. Set width to 0 for any column to prevent
        it from being displayed. This default implementation gives
        the columns equal width."""
        ncol = len(self.content[0].getValues()) if self.content else 2
        wid = self.cwid - 3
        def setCwids(wids):
            self.cwidths = [(0,3)]
            col = 4
            for wid in wids:
                self.cwidths.append((col, wid))
                col += wid + 2
        if wid > 100:
            datewid = 16
            sizewid = 6
            wid -= 16+6
            wid -= 12            # column gaps
            subjwid = int(wid * 0.6)
            fromwid = wid - subjwid
            setCwids((subjwid, fromwid, datewid, sizewid))
        elif wid > 80:
            datewid = 16
            wid -= 16
            wid -= 10            # column gaps
            subjwid = int(wid * 0.6)
            fromwid = wid - subjwid
            setCwids((subjwid, fromwid, datewid))
        else:
            wid -= 8            # column gaps
            subjwid = int(wid * 0.6)
            fromwid = wid - subjwid
            setCwids((subjwid, fromwid))
        return self

class MessageOptionScreen(screens.ColumnOptionScreen):
    def _createContent(self):
        self.contentW = MessageOptionsList(self, self.contentHgt,-1,
                self.contentY,0, self.content, self.cmds)


#       MESSAGE VIEWER

EMAIL_HELP = u"""
Email message viewer:

 F1 ?          this text
 ↓ j           down one line
 ↑ k           up one line
 PGDN > ^F SP  next page
 PGUP < ^B     previous page
 HOME ^        top
 END  $        end
 ^L            refresh screen
 ^C            exit trm
 q ESC         return to previous screen
 x             return to previous screen without saving changes

 H             toggle full header view

 n             next message
 p             previous message
 N             next unread
 ^N            next unread with same subject
 P             previous unread
 ^P            previous unread with same subject

 d             delete current email %s
 D             delete entire thread
 m             mark as read
 M             mark entire thread as read
 u             mark as unread
 U             mark entire thread as unread"""

def EmailScreen(win, account, mbox, summaries, idx):
    """Display the selected message."""

    summary = summaries[idx]
    msg = summary.getMessage(mbox)
    # TODO: handle not found
    # If multipart, search for a text/plain part
    longHeaders = False
    if msg.is_multipart():
        charset = None
        text = None
        html = None
        for part in msg.walk():
            if part.is_multipart():
                continue
            if part.get_param("text/plain") is not None:
                # Found it
                charset = part.get_param("charset")
                text = part.get_payload(decode=True)
                break
            if part.get_param("text/html") is not None:
                # We can use html if plain is not found
                charset = part.get_param("charset")
                text = part.get_payload(decode=True)
    else:
        charset = msg.get_param("charset")
        text = msg.get_payload(decode=True)

    if not text: text = u"No plain text found for this message"
    if charset:
        try:
            text = text.decode(charset, errors="replace")
        except LookupError:
            pass

    optScreen = EmailScreenSetup(win, account, mbox, idx, msg, text, longHeaders)
    optScreen.redraw().refresh()

    writeLog("EmailScreen about to enter main loop")
    while True:
        key = getUchar(win)
        writeLog("Received character %s" % keystr(key))
        if key == u'q':
            mbox.chFlags(idx, messageSummary.FLAG_READ, 0)
            # Nothing is actually written until the user closes the mailbox.
            return key
        if key in (u'x', ESC):
            return key
        if key in (u'?', curses.KEY_F1):
            screens.HelpScreen(win, EMAIL_HELP % ("(move to Trash)" if not mbox.isTrash() else "permanently"))
            optScreen.redraw().refresh()
            continue
        if key == u'H':
            longHeaders = not longHeaders
            optScreen.setContent(EmailContent(msg, text, longHeaders)).refresh()
            continue
        if isinstance(key, basestring) and key in "npNPdD":
            mbox.chFlags(idx, messageSummary.FLAG_READ, 0)
            return key
        # TODO: m,M,S,t,u
        if optScreen.handleKey(key):
            # TODO: really necessary?
            #optScreen.refresh()
            continue
        writeLog("Ignoring key code %s" % keystr(key))
        # TODO: detect changes

def EmailScreenSetup(win, account, mbox, idx, msg, text, longHeaders):
    writeLog("email content: %s" % EmailContent(msg, text, longHeaders))
    optScreen = screens.TextPagerScreen(win, EmailContent(msg, text, longHeaders),
        "Message %d/%d" % (idx+1, mbox.nmessages()),
        (("? Help", "↑ Up one", "PGUP < Page up", "HOME ^ Top", "n Next msg", "N Next unread", "q Return", "d Delete", "q Quit"),
         ("", "↓ Down one", "PGDN > Page down", "END  $ Bottom", "p Prev msg", "P Prev unread", "x Abort")))
    optScreen.resize()
    return optScreen

def EmailContent(msg, text, longHeaders):
    headers = []
    if not longHeaders:
        if "From" in msg: headers.append(u"From: " + parseIso(msg["From"]))
        if "Subject" in msg: headers.append(u"Subject: " + parseIso(msg["Subject"]))
        if "To" in msg: headers.append(u"To: " + parseIso(msg["To"]))
        if "Date" in msg: headers.append(u"Date: " + parseIso(msg["Date"]))
    else:
        for hdr in msg.keys():
            headers.append(unicode(hdr) + ": " + parseIso(msg[hdr]))
    return u"\n".join(headers) + u'\n\n' + unescape(text)


#       UTILITIES

def SecurityCheck(rcfile):
    try:
        sb = os.stat(rcfile)
    except OSError:
        return

    # Should be read-write to owner only.
    mode = stat.S_IMODE(sb.st_mode)
    if mode & 0177:
        if mode & 066:
            print("\n\n\nWarning: file \"%s\" was readable or writeable" % rcfile)
            print("by others (mode %o)" % mode)
            print("\nThis has been changed to mode 0600 (rw-------) for security.")
            print("If you had any passwords stored in this file,")
            print("you should consider changing them.")
        try:
            os.chmod(rcfile, 0600)
        except Exception as e:
            print('Failed to change mode of "%s" to %o, %s"' % (rcfile, 0600, e), file=sys.stderr)
        if mode & 066:
            raw_input("\nHit enter to continue: ")

def ReadConfig(rcfile, mailrc):
    config = configparser.ConfigParser()
    if os.path.isfile(rcfile):
        try:
            config.read(rcfile)
        except:
            pass
    if not config.has_section("global"):
        config.add_section("global")
        config.set("global","splashscreen", "0")

    # Read the old .mailrc file while we're here
    if os.path.isfile(mailrc):
        try:
            with open(mailrc, "r") as ifile:
                if not config.has_section("mailrc"):
                    config.add_section("mailrc")
                # Looking for "folder" variable.
                for line in ifile:
                    line = line.strip()
                    if line.startswith('#'): continue
                    mo = set_re.match(line)
                    if mo:
                        if mo.group(1) == "folder":
                            config.set("mailrc", "folder", mo.group(2).strip('"'))
        except Exception as e:
            print("Failed to read \"%s\", %s, ignored" % (mailrc, e), file=sys.stderr)

    return config

def WriteConfig(config, rcfile):
    try:
        config.remove_section("mailrc")
        config.write(open(rcfile,"w"))
    except Exception as e:
        print("Failed to write \"%s\"," % rcfile, e, file=sys.stderr)

def getAccounts(config):
    accounts = []
    getLocalAccount(accounts)
    for section in config.sections():
        if section.startswith("account "):
            name = section[8:].strip('"')
            config.set(section, "name", name)
            accounts.append(imap.imapAccount.fromConfig(name, section, config))
    return accounts

set_re = re.compile(r""" *set +(\w+)=(.+)""")   # For parsing .mailrc
def getLocalAccount(accounts):
    """Check for the presence of email on the local machine."""
    def getUserMail():
        path = os.path.join("/var/mail", os.environ["USER"])
        if os.path.isfile(path): return path
        path = os.path.join("/var/spool/mail", os.environ["USER"])
        if os.path.isfile(path): return path
        return None
    if "USER" in os.environ:
        userMail = getUserMail()
        writeLog("userMail = %s" % userMail)
        if userMail:
            # Where will user keep their local mail?
            if config.has_option("mailrc", "folder"):
                folder = config.get("mailrc", "folder")
                if not folder.startswith('/'):
                    folder = os.path.join(HOME, folder)
                    config.set("mailrc", "folder", folder)
                    writeLog("folder = %s" % folder)
            elif os.path.isdir(os.path.join(HOME, "mail")):
                configSet(config, "mailrc", "folder", os.path.join(HOME, "mail"))

            account = mbox.MboxAccount("local", userMail, config)
            accounts.append(account)

def percent(a,b):
    return 100*a//(b-1) if b > 1 else 100


if __name__ == '__main__':
    signal.signal(signal.SIGPIPE, signal.SIG_DFL)
    signal.signal(signal.SIGTSTP, signal.SIG_IGN)
    sys.exit(main())
